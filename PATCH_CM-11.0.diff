diff -ur a/build/core/tasks/kernel.mk b/build/core/tasks/kernel.mk
--- a/build/core/tasks/kernel.mk	2016-02-06 00:00:00.000000000 +0000
+++ b/build/core/tasks/kernel.mk	2016-02-06 00:00:00.000000000 +0000
@@ -156,9 +156,9 @@
     endif
     ifneq ($(TARGET_KERNEL_CUSTOM_TOOLCHAIN),)
         ifeq ($(HOST_OS),darwin)
-            ARM_CROSS_COMPILE:=CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilt/darwin-x86/toolchain/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"
+            ARM_CROSS_COMPILE:=CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilts/gcc/darwin-x86/arm/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"
         else
-            ARM_CROSS_COMPILE:=CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilt/linux-x86/toolchain/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"
+            ARM_CROSS_COMPILE:=CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilts/gcc/linux-x86/arm/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"
         endif
     else
         ARM_CROSS_COMPILE:=CROSS_COMPILE="$(ccache) $(ARM_EABI_TOOLCHAIN)/arm-eabi-"
diff -ur a/external/bluetooth/bluedroid/audio_a2dp_hw/audio_a2dp_hw.c b/external/bluetooth/bluedroid/audio_a2dp_hw/audio_a2dp_hw.c
--- a/external/bluetooth/bluedroid/audio_a2dp_hw/audio_a2dp_hw.c	2016-02-06 00:00:00.000000000 +0000
+++ b/external/bluetooth/bluedroid/audio_a2dp_hw/audio_a2dp_hw.c	2016-02-06 00:00:00.000000000 +0000
@@ -775,9 +775,7 @@
     /* dump params */
     str_parms_dump(parms);
 
-    retval = str_parms_get_str(parms, "closing", keyval, sizeof(keyval));
-
-    if (retval >= 0)
+    if (str_parms_get_str(parms, "closing", keyval, sizeof(keyval)) >= 0)
     {
         if (strcmp(keyval, "true") == 0)
         {
@@ -788,9 +786,7 @@
         }
     }
 
-    retval = str_parms_get_str(parms, "A2dpSuspended", keyval, sizeof(keyval));
-
-    if (retval >= 0)
+    if (str_parms_get_str(parms, "closing", keyval, sizeof(keyval)) >= 0)
     {
         pthread_mutex_lock(&out->lock);
         if (strcmp(keyval, "true") == 0)
diff -ur a/frameworks/av/include/media/stagefright/ColorConverter.h b/frameworks/av/include/media/stagefright/ColorConverter.h
--- a/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-06 00:00:00.000000000 +0000
@@ -79,6 +79,9 @@
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
 
+    status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);
+
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff -ur a/frameworks/av/media/libstagefright/ACodec.cpp b/frameworks/av/media/libstagefright/ACodec.cpp
--- a/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -496,11 +496,7 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (mStoreMetaDataInOutputBuffers) {
-            err = allocateOutputMetaDataBuffers();
-        } else {
-            err = allocateOutputBuffersFromNativeWindow();
-        }
+        err = allocateOutputBuffersFromNativeWindow();
     } else {
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
@@ -654,11 +650,29 @@
             eHalHeight,
             eHalColorFormat);
 #else
+
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+
+    ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:
+            ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19);
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        default:
+            ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: default(%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", def.format.video.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+    }
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 #endif
 
     if (err != 0) {
@@ -1834,6 +1848,31 @@
     format.nIndex = 0;
     bool found = false;
 
+    ALOGI("PATCH:ACodec:setVideoPortFormatType Begin colorFormat: %i", colorFormat);
+    ALOGI("PATCH:ACodec:setVideoPortFormatType Begin format.eColorFormat: %i", format.eColorFormat);
+
+    if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+        if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+            ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+            format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+                if (errs != OK){
+                    ALOGE("PATCH:ACodec:setVideoPortFormatType setParameter failed: %d", errs);
+                }
+            ALOGI("PATCH:ACodec:setVideoPortFormatType format.eColorFormat set %i", format.eColorFormat);
+        }
+    }
+    ALOGI("PATCH:ACodec:setVideoPortFormatType End format.eColorFormat : %i", format.eColorFormat);
+    if(colorFormat == OMX_COLOR_FormatYCbYCr){
+        if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+            ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+            colorFormat = OMX_COLOR_FormatYUV420Planar;
+            ALOGI("PATCH:ACodec:setVideoPortFormatType colorFormat set %i", colorFormat);
+        }
+    }
+    ALOGI("PATCH:ACodec:setVideoPortFormatType End format.eColorFormat : %i", colorFormat);
+
+
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
@@ -1873,9 +1912,21 @@
     }
 
     if (!found) {
+        ALOGI("PATCH:ACodec:setVideoPortFormatType UNKNOWN_ERROR");
         return UNKNOWN_ERROR;
     }
 
+    ALOGI("PATCH:ACodec:setVideoPortFormatType : %i", format.eColorFormat);
+
+    if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+        if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+            ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+            format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            ALOGI("PATCH:ACodec:setVideoPortFormatType set %i", format.eColorFormat);
+        }
+    }
+    ALOGI("PATCH:ACodec:setVideoPortFormatType end : %i", format.eColorFormat);
+
     status_t err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -1892,9 +1943,29 @@
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
+
+    ALOGI("PATCH:ACodec:setSupportedOutputFormat : %i", format.eColorFormat);
+
     CHECK_EQ(err, (status_t)OK);
     CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+    if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+        if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+            ALOGI("PATCH:ACodec:setSupportedOutputFormat is brcm");
+            format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+                if (errs != OK){
+                    ALOGE("PATCH:ACodec:setSupportedOutputFormat setParameter failed: %d", errs);
+                }
+            ALOGI("PATCH:ACodec:setSupportedOutputFormat format.eColorFormat set %i", format.eColorFormat);
+        }
+    }
+    ALOGI("PATCH:ACodec:setSupportedOutputFormat end : %i", format.eColorFormat);
+
+    mOMX->setParameter(
+              mNode, OMX_IndexParamVideoPortFormat,
+              &format, sizeof(format));
+
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -2589,9 +2660,24 @@
 
     CHECK_EQ(err, (status_t)OK);
 
+    ALOGI("PATCH:ACodec:setVideoFormatOnPort: %i", def.format.video.eColorFormat);
+
+    if(def.format.video.eColorFormat == OMX_COLOR_FormatYCbYCr){
+        if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+            ALOGI("PATCH:ACodec:setVideoFormatOnPort set %i", OMX_COLOR_FormatYUV420Planar);
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            status_t errs = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            if (errs != OK){
+                ALOGE("PATCH:ACodec:setVideoFormatOnPort setParameter failed: %d", errs);
+            }
+        }
+    }
+
+    ALOGI("PATCH:ACodec:setVideoFormatOnPort: %i end", def.format.video.eColorFormat);
+
     if (portIndex == kPortIndexInput) {
         // XXX Need a (much) better heuristic to compute input buffer sizes.
-        const size_t X = 64 * 1024;
+        const size_t X = 64 * 8 * 1024;
         if (def.nBufferSize < X) {
             def.nBufferSize = X;
         }
@@ -2750,6 +2836,8 @@
                 notify->setInt32("slice-height", videoDef->nSliceHeight);
                 notify->setInt32("color-format", videoDef->eColorFormat);
 
+                ALOGI("PATCH:ACodec:sendFormatChange: %i", videoDef->eColorFormat);
+
                 OMX_CONFIG_RECTTYPE rect;
                 InitOMXParams(&rect);
                 rect.nPortIndex = kPortIndexOutput;
diff -ur a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
--- a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -55,6 +55,7 @@
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+        case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -101,6 +102,10 @@
         size_t dstWidth, size_t dstHeight,
         size_t dstCropLeft, size_t dstCropTop,
         size_t dstCropRight, size_t dstCropBottom) {
+
+    ALOGE("PATCH:ColorConverter:convert: mSrcFormat: %i", mSrcFormat);
+    ALOGE("PATCH:ColorConverter:convert: mDstFormat: %i", mDstFormat);
+
     if (mDstFormat != OMX_COLOR_Format16bitRGB565) {
         return ERROR_UNSUPPORTED;
     }
@@ -130,6 +135,10 @@
             err = convertCbYCrY(src, dst);
             break;
 
+        case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break;
+
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
             break;
@@ -162,6 +171,7 @@
 
 status_t ColorConverter::convertCbYCrY(
         const BitmapParams &src, const BitmapParams &dst) {
+        ALOGE("PATCH:ColorConverter:convertCbYCrY");
     // XXX Untested
 
     uint8_t *kAdjustedClip = initClip();
@@ -224,8 +234,74 @@
     return OK;
 }
 
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+        ALOGE("PATCH:ColorConverter:convertYCbYCr");
+    // XXX Untested
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+            signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
 status_t ColorConverter::convertYUV420Planar(
         const BitmapParams &src, const BitmapParams &dst) {
+        ALOGE("PATCH:ColorConverter:convertYUV420Planar");
     if (!((src.mCropLeft & 1) == 0
             && src.cropWidth() == dst.cropWidth()
             && src.cropHeight() == dst.cropHeight())) {
diff -ur a/frameworks/av/media/libstagefright/OMXCodec.cpp b/frameworks/av/media/libstagefright/OMXCodec.cpp
--- a/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -501,6 +501,8 @@
     CHECK(success);
     Vector<CodecNameAndQuirks> matchingCodecs;
 
+    ALOGI("PATCH:OMXCodec:Create mime: %s", mime);
+
 #ifdef QCOM_HARDWARE
     ExtendedCodec::kHEVCCodecType hevc_codectype = ExtendedCodec::useHEVCDecoder(mime);
     int channelCount = 0;
@@ -1098,6 +1100,7 @@
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
 
+        ALOGI("PATCH:OMXCodec:setVideoPortFormatType : %i", format.eColorFormat);
         if (err != OK) {
             return err;
         }
@@ -1150,6 +1153,7 @@
     status_t err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
+    ALOGI("PATCH:OMXCodec:setVideoPortFormatType end : %i", format.eColorFormat);
 
     return err;
 }
@@ -1797,8 +1801,23 @@
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
         CHECK_EQ(err, (status_t)OK);
+
+        ALOGI("PATCH:OMXCodec:setVideoOutputFormat begin : %i, component %s", format.eColorFormat, mComponentName);
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+        if (format.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+            ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX_COLOR_FormatYCbYCr");
+            if (!strncmp(mComponentName, "OMX.brcm.", 9)){
+                ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX.brcm.");
+                format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+                ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX_COLOR_FormatYCbYCr -> OMX_COLOR_FormatYUV420Planar");
+                status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+                if (errs != OK){
+                    ALOGE("PATCH:OMXCodec:setVideoOutputFormat: setParameter failed: %d", errs);
+                }
+            }
+        }
+
 #if 0
         CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
@@ -1833,6 +1852,7 @@
                 err = mOMX->getParameter(
                         mNode, OMX_IndexParamVideoPortFormat,
                             &format, sizeof(format));
+                ALOGI("PATCH:OMXCodec:setVideoOutputFormat : %i", format.eColorFormat);
                 if (format.eColorFormat == colorFormat) {
                     break;
                 }
@@ -1866,11 +1886,7 @@
 
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
-#ifdef USE_SAMSUNG_COLORFORMAT
     const size_t X = 64 * 8 * 1024;
-#else
-    const size_t X = 64 * 1024;
-#endif
     if (def.nBufferSize < X) {
         def.nBufferSize = X;
     }
@@ -2164,6 +2180,7 @@
 }
 
 status_t OMXCodec::allocateBuffers() {
+    ALOGI("PATCH:OMXCodec:allocateBuffers");
     status_t err = allocateBuffersOnPort(kPortIndexInput);
 
     if (err != OK) {
@@ -2174,6 +2191,11 @@
 }
 
 status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
+
+    ALOGI("PATCH:OMXCodec:allocateBuffersOnPort");
+    ALOGI("PATCH:OMXCodec:allocateBuffersOnPort dump port");
+    dumpPortStatus(portIndex);
+
 #ifdef MTK_HARDWARE
     if (!strncmp(mComponentName, "OMX.MTK.", 8)) {
         return mMtkBufferAllocator->allocateBuffersOnPort(portIndex);
@@ -2389,6 +2411,8 @@
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
+    ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow -> [%s]", mComponentName);
+
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     if (err != OK) {
@@ -2396,6 +2420,9 @@
         return err;
     }
 
+    ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow dump port");
+    dumpPortStatus(kPortIndexOutput);
+
 #ifndef USE_SAMSUNG_COLORFORMAT
 #ifdef MTK_HARDWARE
     uint32_t eHalColorFormat;
@@ -2428,11 +2455,37 @@
             def.format.video.nSliceHeight,
             eHalColorFormat);
 #else
+
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    status_t errss;
+
+    ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:
+            ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19);
+            ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            errss = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            if (errss != OK){
+                ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow setParameter failed: %d", errss);
+            }
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        case OMX_COLOR_FormatYUV420Planar:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        default:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+            HalColorFormat = def.format.video.eColorFormat;
+        break;
+    }
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 #endif
 #else
     OMX_COLOR_FORMATTYPE eColorFormat;
@@ -2619,6 +2672,9 @@
         }
     }
 
+    ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow end dump port");
+    dumpPortStatus(kPortIndexOutput);
+
     return err;
 }
 
@@ -5810,30 +5866,30 @@
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
 
-    printf("%s Port = {\n", portIndex == kPortIndexInput ? "Input" : "Output");
+    ALOGI("%s Port = {\n", portIndex == kPortIndexInput ? "Input" : "Output");
 
     CHECK((portIndex == kPortIndexInput && def.eDir == OMX_DirInput)
           || (portIndex == kPortIndexOutput && def.eDir == OMX_DirOutput));
 
-    printf("  nBufferCountActual = %ld\n", def.nBufferCountActual);
-    printf("  nBufferCountMin = %ld\n", def.nBufferCountMin);
-    printf("  nBufferSize = %ld\n", def.nBufferSize);
+    ALOGI("  nBufferCountActual = %ld\n", def.nBufferCountActual);
+    ALOGI("  nBufferCountMin = %ld\n", def.nBufferCountMin);
+    ALOGI("  nBufferSize = %ld\n", def.nBufferSize);
 
     switch (def.eDomain) {
         case OMX_PortDomainImage:
         {
             const OMX_IMAGE_PORTDEFINITIONTYPE *imageDef = &def.format.image;
 
-            printf("\n");
-            printf("  // Image\n");
-            printf("  nFrameWidth = %ld\n", imageDef->nFrameWidth);
-            printf("  nFrameHeight = %ld\n", imageDef->nFrameHeight);
-            printf("  nStride = %ld\n", imageDef->nStride);
+            ALOGI("\n");
+            ALOGI("  // Image\n");
+            ALOGI("  nFrameWidth = %ld\n", imageDef->nFrameWidth);
+            ALOGI("  nFrameHeight = %ld\n", imageDef->nFrameHeight);
+            ALOGI("  nStride = %ld\n", imageDef->nStride);
 
-            printf("  eCompressionFormat = %s\n",
+            ALOGI("  eCompressionFormat = %s\n",
                    imageCompressionFormatString(imageDef->eCompressionFormat));
 
-            printf("  eColorFormat = %s\n",
+            ALOGI("  eColorFormat = %s\n",
                    colorFormatString(imageDef->eColorFormat));
 
             break;
@@ -5843,16 +5899,16 @@
         {
             OMX_VIDEO_PORTDEFINITIONTYPE *videoDef = &def.format.video;
 
-            printf("\n");
-            printf("  // Video\n");
-            printf("  nFrameWidth = %ld\n", videoDef->nFrameWidth);
-            printf("  nFrameHeight = %ld\n", videoDef->nFrameHeight);
-            printf("  nStride = %ld\n", videoDef->nStride);
+            ALOGI("\n");
+            ALOGI("  // Video\n");
+            ALOGI("  nFrameWidth = %ld\n", videoDef->nFrameWidth);
+            ALOGI("  nFrameHeight = %ld\n", videoDef->nFrameHeight);
+            ALOGI("  nStride = %ld\n", videoDef->nStride);
 
-            printf("  eCompressionFormat = %s\n",
+            ALOGI("  eCompressionFormat = %s\n",
                    videoCompressionFormatString(videoDef->eCompressionFormat));
 
-            printf("  eColorFormat = %s\n",
+            ALOGI("  eColorFormat = %s\n",
                    colorFormatString(videoDef->eColorFormat));
 
             break;
@@ -5862,9 +5918,9 @@
         {
             OMX_AUDIO_PORTDEFINITIONTYPE *audioDef = &def.format.audio;
 
-            printf("\n");
-            printf("  // Audio\n");
-            printf("  eEncoding = %s\n",
+            ALOGI("\n");
+            ALOGI("  // Audio\n");
+            ALOGI("  eEncoding = %s\n",
                    audioCodingTypeString(audioDef->eEncoding));
 
             if (audioDef->eEncoding == OMX_AUDIO_CodingPCM) {
@@ -5876,16 +5932,16 @@
                         mNode, OMX_IndexParamAudioPcm, &params, sizeof(params));
                 CHECK_EQ(err, (status_t)OK);
 
-                printf("  nSamplingRate = %ld\n", params.nSamplingRate);
-                printf("  nChannels = %ld\n", params.nChannels);
-                printf("  bInterleaved = %d\n", params.bInterleaved);
-                printf("  nBitPerSample = %ld\n", params.nBitPerSample);
+                ALOGI("  nSamplingRate = %ld\n", params.nSamplingRate);
+                ALOGI("  nChannels = %ld\n", params.nChannels);
+                ALOGI("  bInterleaved = %d\n", params.bInterleaved);
+                ALOGI("  nBitPerSample = %ld\n", params.nBitPerSample);
 
-                printf("  eNumData = %s\n",
+                ALOGI("  eNumData = %s\n",
                        params.eNumData == OMX_NumericalDataSigned
                         ? "signed" : "unsigned");
 
-                printf("  ePCMMode = %s\n", audioPCMModeString(params.ePCMMode));
+                ALOGI("  ePCMMode = %s\n", audioPCMModeString(params.ePCMMode));
             } else if (audioDef->eEncoding == OMX_AUDIO_CodingAMR) {
                 OMX_AUDIO_PARAM_AMRTYPE amr;
                 InitOMXParams(&amr);
@@ -5895,10 +5951,10 @@
                         mNode, OMX_IndexParamAudioAmr, &amr, sizeof(amr));
                 CHECK_EQ(err, (status_t)OK);
 
-                printf("  nChannels = %ld\n", amr.nChannels);
-                printf("  eAMRBandMode = %s\n",
+                ALOGI("  nChannels = %ld\n", amr.nChannels);
+                ALOGI("  eAMRBandMode = %s\n",
                         amrBandModeString(amr.eAMRBandMode));
-                printf("  eAMRFrameFormat = %s\n",
+                ALOGI("  eAMRFrameFormat = %s\n",
                         amrFrameFormatString(amr.eAMRFrameFormat));
             }
 
@@ -5907,12 +5963,12 @@
 
         default:
         {
-            printf("  // Unknown\n");
+            ALOGI("  // Unknown\n");
             break;
         }
     }
 
-    printf("}\n");
+    ALOGI("}\n");
 }
 
 status_t OMXCodec::initNativeWindow() {
@@ -5946,6 +6002,7 @@
 }
 
 void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
+    ALOGI("PATCH:OMXCodec:initOutputFormat");
     mOutputFormat = new MetaData;
     mOutputFormat->setCString(kKeyDecoderComponent, mComponentName);
     if (mIsEncoder) {
@@ -5966,6 +6023,7 @@
     switch (def.eDomain) {
         case OMX_PortDomainImage:
         {
+            ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainImage");
             OMX_IMAGE_PORTDEFINITIONTYPE *imageDef = &def.format.image;
             CHECK_EQ((int)imageDef->eCompressionFormat,
                      (int)OMX_IMAGE_CodingUnused);
@@ -5979,6 +6037,7 @@
 
         case OMX_PortDomainAudio:
         {
+            ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainAudio");
             OMX_AUDIO_PORTDEFINITIONTYPE *audio_def = &def.format.audio;
 
             if (audio_def->eEncoding == OMX_AUDIO_CodingPCM) {
@@ -6086,6 +6145,16 @@
 
         case OMX_PortDomainVideo:
         {
+            ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo");
+            
+            if (!strncmp(mComponentName, "OMX.brcm.", 9)){
+                    ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo Codec is brcm");
+                    OMX_VIDEO_PORTDEFINITIONTYPE *vdef = &def.format.video;
+                    vdef->eColorFormat = OMX_COLOR_FormatYUV420Planar;
+                    ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo Codec is brcm set OMX_IndexParamPortDefinition eColorFormat = OMX_COLOR_FormatYUV420Planar");
+                    mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            }
+
             OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
 
             if (video_def->eCompressionFormat == OMX_VIDEO_CodingUnused) {
@@ -6110,7 +6179,19 @@
             mOutputFormat->setInt32(kKeyStride, video_def->nStride);
             mOutputFormat->setInt32(kKeySliceHeight, video_def->nSliceHeight);
 #endif
+
+            ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo BEGIN video_def->eColorFormat %i", video_def->eColorFormat);
+            
+            if(video_def->eColorFormat == OMX_COLOR_FormatYCbYCr){
+                ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo eColorFormat == OMX_COLOR_FormatYCbYCr");
+                if (!strncmp(mComponentName, "OMX.brcm.", 9)){
+                    ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo kKeyColorFormat set %i", OMX_COLOR_FormatYUV420Planar);
+                    video_def->eColorFormat = OMX_COLOR_FormatYUV420Planar;
+                }
+            }
+            
             mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
+            ALOGI("PATCH:OMXCodec:initOutputFormat OMX_PortDomainVideo END video_def->eColorFormat %i", video_def->eColorFormat);
 
             if (!mIsEncoder) {
                 OMX_CONFIG_RECTTYPE rect;
@@ -6269,6 +6350,8 @@
     for (size_t c = 0; c < matchingCodecs.size(); c++) {
         const char *componentName = matchingCodecs.itemAt(c).mName.string();
 
+        ALOGI("PATCH:QueryCodecs: %s", componentName);
+
         results->push();
         CodecCapabilities *caps = &results->editItemAt(results->size() - 1);
 
@@ -6288,15 +6371,18 @@
         const char *componentName, const char *mime,
         bool isEncoder,
         CodecCapabilities *caps) {
+        ALOGI("PATCH:QueryCodec: %s", componentName);
     if (strncmp(componentName, "OMX.", 4)) {
         // Not an OpenMax component but a software codec.
         caps->mFlags = 0;
         caps->mComponentName = componentName;
         return OK;
     }
+    caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
 
     sp<OMXCodecObserver> observer = new OMXCodecObserver;
     IOMX::node_id node;
+    ALOGI("PATCH:QueryCodec->allocateNode");
     status_t err = omx->allocateNode(componentName, observer, &node);
 
     if (err != OK) {
@@ -6337,7 +6423,9 @@
 #else
     portFormat.nPortIndex = !isEncoder ? 1 : 0;
 #endif
+
     for (OMX_U32 index = 0;;index++) {
+        ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:begin");
         portFormat.nIndex = index;
         err = omx->getParameter(
                 node, OMX_IndexParamVideoPortFormat,
@@ -6345,8 +6433,28 @@
         if (err != OK) {
             break;
         }
-        caps->mColorFormats.push(portFormat.eColorFormat);
-    }
+        ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:Begin portFormat.eColorFormat = %i, componentName = %s", portFormat.eColorFormat, componentName);
+        if (portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+            ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE: OMX_COLOR_FormatYCbYCr");
+            if (!strncmp(componentName, "OMX.brcm.", 9)){
+                ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE (%s)", componentName);
+                portFormat.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+                ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE portFormat.eColorFormat(%i)", portFormat.eColorFormat);
+                status_t errs = omx->setParameter(node, OMX_IndexParamVideoPortFormat, &portFormat, sizeof(portFormat));
+                if (errs != OK){
+                    ALOGE("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE setParameter failed: %d", errs);
+                }
+                caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+            }else{
+                ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE color is YCbYCr but not brcm (%s)", componentName);
+                caps->mColorFormats.push(portFormat.eColorFormat);
+            }
+        }else{
+            ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE color not YCbYCr (%i)", portFormat.eColorFormat);
+            caps->mColorFormats.push(portFormat.eColorFormat);
+        }
+        ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:End portFormat.eColorFormat = %i, componentName = %s", portFormat.eColorFormat, componentName);
+   }
 
     if (!isEncoder && !strncmp(mime, "video/", 6)) {
         if (omx->storeMetaDataInBuffers(
diff -ur a/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java b/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java
--- a/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-06 00:00:00.000000000 +0000
@@ -957,35 +957,11 @@
      * @hide
      */
     public static void setTelephonyProperty(String property, int index, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
-
-        if (index < 0) return;
-
-        for (int i = 0; i < index; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
+        if (index != 0) {
+            property += "_" + index;
         }
 
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = index+1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-        SystemProperties.set(property, propVal);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -994,16 +970,10 @@
      * @hide
      */
     public static String getTelephonyProperty(String property, int index, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((index >= 0) && (index < values.length) && (values[index] != null)) {
-                propVal = values[index];
-            }
+        if (index != 0) {
+            property += "_" + index;
         }
-        return propVal == null ? defaultVal : propVal;
+        return SystemProperties.get(property, defaultVal);
     }
 
     /**
diff -ur a/frameworks/native/libs/gui/SensorEventQueue.cpp b/frameworks/native/libs/gui/SensorEventQueue.cpp
--- a/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -128,8 +128,12 @@
 
 status_t SensorEventQueue::enableSensor(int32_t handle, int32_t samplingPeriodUs,
                                         int maxBatchReportLatencyUs, int reservedFlags) const {
-    return mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
+    status_t err = mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
                                                  us2ns(maxBatchReportLatencyUs), reservedFlags);
+    if (err == NO_ERROR) {
+        mSensorEventConnection->setEventRate(handle, us2ns(samplingPeriodUs));
+    }
+    return err;
 }
 
 status_t SensorEventQueue::flush() const {
diff -ur a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -1234,13 +1234,18 @@
         //getLayer()->compositionType = HWC_FRAMEBUFFER;
     }
     virtual void setPlaneAlpha(uint8_t alpha) {
+    // HAWAII_HWC does not respect planeAlpha despite being v1.2
+    #ifndef HAWAII_HWC
         if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
             getLayer()->planeAlpha = alpha;
         } else {
+    #endif
             if (alpha < 0xFF) {
                 getLayer()->flags |= HWC_SKIP_LAYER;
             }
+    #ifndef HAWAII_HWC
         }
+    #endif
     }
     virtual void setDefaultState() {
         hwc_layer_1_t* const l = getLayer();
diff -ur a/frameworks/native/services/surfaceflinger/Layer.cpp b/frameworks/native/services/surfaceflinger/Layer.cpp
--- a/frameworks/native/services/surfaceflinger/Layer.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/native/services/surfaceflinger/Layer.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -1260,6 +1260,8 @@
 
 void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) {
     uint32_t orientation = 0;
+    // HAWAII_HWC has display problem in landscape mode when transform is used
+    #ifndef HAWAII_HWC
     if (!mFlinger->mDebugDisableTransformHint) {
         // The transform hint is used to improve performance, but we can
         // only have a single transform hint, it cannot
@@ -1270,6 +1272,7 @@
             orientation = 0;
         }
     }
+    #endif
     mSurfaceFlingerConsumer->setTransformHint(orientation);
     mTransformHint = orientation;
 }
diff -ur a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-06 00:00:00.000000000 +0000
@@ -1162,6 +1162,7 @@
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+            #ifndef HAWAII_HWC
                 // Get the layers in the current drawying state
                 const LayerVector& layers(mDrawingState.layersSortedByZ);
                 bool freezeSurfacePresent = false;
@@ -1181,7 +1182,7 @@
                         }
                     }
                 }
-
+            #endif
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
                 const size_t count = currentLayers.size();
@@ -1194,6 +1195,7 @@
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+            #ifndef HAWAII_HWC
                     if(freezeSurfacePresent) {
                         // if freezeSurfacePresent, set ANIMATING flag
                         cur->setAnimating(true);
@@ -1218,6 +1220,7 @@
                             lastSurfaceViewLayer = layer;
                         }
                     }
+            #endif
                 }
             }
         }
@@ -3392,6 +3395,11 @@
 {
     ATRACE_CALL();
 
+    // Rotation artifact problems when useReadPixels is false
+    #ifdef HAWAII_HWC
+        useReadPixels = true;
+    #endif
+
     // get screen geometry
     const uint32_t hw_w = hw->getWidth();
     const uint32_t hw_h = hw->getHeight();
diff -ur a/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-06 00:00:00.000000000 +0000
@@ -334,6 +334,16 @@
             case RINGING:
                 if (VDBG) Rlog.d(LOG_TAG, "setAudioMode RINGING");
                 int curAudioMode = mAudioManager.getMode();
+                // HACK: When Dual-SIM is enabled and call waiting occurs,
+                // com.android.phone.CallCommandService.setActiveSubscription
+                // will cause setAudioMode to be called, causing the audio
+                // mode to be chagned to "MODE_RINGTONE", rendering the active
+                // conversation to be inaudiable.
+                // (The setAudioMode() call does not occur without Dual-SIM.)
+                if (curAudioMode == AudioManager.MODE_IN_CALL) {
+                    Rlog.d(LOG_TAG, "Skip MODE_IN_CALL -> MODE_RINGTONE (assume call waiting)");
+                    return;
+                }
                 if (curAudioMode != AudioManager.MODE_RINGTONE) {
                     // only request audio focus if the ringtone is going to be heard
                     if (mAudioManager.getStreamVolume(AudioManager.STREAM_RING) > 0
diff -ur a/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-06 00:00:00.000000000 +0000
@@ -150,6 +150,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+    boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -329,6 +330,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+        // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -1381,6 +1387,18 @@
     protected void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+
+        // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -1522,6 +1540,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+        pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur a/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java b/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java
--- a/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-06 00:00:00.000000000 +0000
@@ -143,11 +143,13 @@
 
 
     //***** Events
-    private static final int EVENT_RADIO_NOT_AVAILABLE = 1;
+    private static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 0;
+    private static final int EVENT_RADIO_ON = 1;
     private static final int EVENT_ICC_CHANGED = 2;
     private static final int EVENT_GET_ICCID_DONE = 3;
     private static final int EVENT_UPDATE_UICC_STATUS = 4;
     private static final int EVENT_SIM_REFRESH = 5;
+    private static final int EVENT_RADIO_NOT_AVAILABLE = 6;
 
     //***** Class Variables
     private static CardSubscriptionManager sCardSubscriptionManager;
@@ -156,6 +158,7 @@
     private CommandsInterface[] mCi;
     private MSimUiccController mUiccController;
     private int mNumPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+    private boolean[] mRadioOn = new boolean[mNumPhones];
     private boolean[] mSubActivated = new boolean[mNumPhones];
 
     private int mUpdateUiccStatusContext = 0;
@@ -203,10 +206,13 @@
         for (int i = 0; i < mCi.length; i++) {
             // Register for Subscription ready event for both the subscriptions.
             Integer slot = new Integer(i);
+            mCi[i].registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, slot);
             mCi[i].registerForNotAvailable(this, EVENT_RADIO_NOT_AVAILABLE, slot);
+            mCi[i].registerForOn(this, EVENT_RADIO_ON, slot);
 
             // Register for SIM Refresh events
             mCi[i].registerForIccRefresh(this, EVENT_SIM_REFRESH, new Integer(i));
+            mRadioOn[i] = false;
             mSubActivated[i] = false;
         }
 
@@ -231,6 +237,16 @@
     @Override
     public void handleMessage(Message msg) {
         switch(msg.what) {
+            case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
+                logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE");
+                processRadioOffOrNotAvailable((AsyncResult)msg.obj);
+                break;
+
+            case EVENT_RADIO_ON:
+                logd("EVENT_RADIO_ON");
+                processRadioOn((AsyncResult)msg.obj);
+                break;
+
             case EVENT_RADIO_NOT_AVAILABLE:
                 logd("EVENT_RADIO_NOT_AVAILABLE");
                 processRadioNotAvailable((AsyncResult)msg.obj);
@@ -280,12 +296,35 @@
         }
     }
 
+    private void processRadioOffOrNotAvailable(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOffOrNotAvailable on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
+            //If sub is deactivated then reset card info.
+            if (mSubActivated[cardIndex] == false) {
+                resetCardInfo(cardIndex);
+                //CardInfo is not valid. Inform others that card info not available.
+                notifyCardInfoNotAvailable(cardIndex,
+                        CardUnavailableReason.REASON_RADIO_UNAVAILABLE);
+                // Reset the flag card info available to false, so that
+                // next time it notifies all cards info available.
+                mAllCardsInfoAvailable = false;
+            }
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
+
     private void processRadioNotAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
 
         logd("processRadioNotAvailable on cardIndex = " + cardIndex);
 
-        if (cardIndex >= 0 && cardIndex < mNumPhones) {
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
             //Radio unavailable comes in case of rild crash or Modem SSR.
             //reset card info in case of radio Unavailable in order to send SET_UICC later.
             resetCardInfo(cardIndex);
@@ -301,6 +340,18 @@
         }
     }
 
+    private void processRadioOn(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOn on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = true;
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
+
     /**
      * Process the ICC_CHANGED notification.
      */
@@ -312,6 +363,10 @@
 
         if ((ar.exception == null) && (ar.result != null)) {
             Integer cardIndex = (Integer) ar.result;
+            if (!mRadioOn[cardIndex]) {
+                logd("handleIccChanged: radio not available - EXIT");
+                return;
+            }
             UiccCard uiccCard = mUiccController.getUiccCards()[cardIndex];
             UiccCard card = mUiccCardList.get(cardIndex).getUiccCard();
 
@@ -451,6 +506,11 @@
 
         logd("handleGetIccIdDone: cardIndex = " + cardIndex);
 
+        if (!mRadioOn[cardIndex]) {
+            logd("handleGetIccIdDone: radio not available - EXIT");
+            return;
+        }
+
         String iccId = null;
 
         if (ar.exception != null) {
@@ -588,7 +648,8 @@
             uiccCard = cardInfo.getUiccCard();
         }
 
-        if (uiccCard == null) {
+        if (uiccCard == null || mRadioOn[cardIndex] == false) {
+            logd("onUpdateUiccStatus(): mRadioOn[" + cardIndex + "] = " + mRadioOn[cardIndex]);
             logd("onUpdateUiccStatus(): NO Card!!!!! at index : " + cardIndex);
             if (mCardSubData[cardIndex] != null) {
                 // Card is removed.
@@ -713,7 +774,7 @@
 
         // Required to notify only once!!!
         // Notify if all card info is available.
-        if (isValidCards() && !mAllCardsInfoAvailable) {
+        if (isValidCards() && !mAllCardsInfoAvailable && mRadioOn[cardIndex]) {
             mAllCardsInfoAvailable = true;
             notifyAllCardsInfoAvailable();
         }
diff -ur a/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java b/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java
--- a/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-06 00:00:00.000000000 +0000
+++ b/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-06 00:00:00.000000000 +0000
@@ -164,6 +164,7 @@
 
     private boolean[] mCardInfoAvailable = new boolean[mNumPhones];
     private boolean[] mIsNewCard = new boolean[mNumPhones];
+    private boolean[] mRadioOn = new boolean[mNumPhones];
 
     private HashMap<SubscriptionId, Subscription> mActivatePending;
     private HashMap<SubscriptionId, Subscription> mDeactivatePending;
@@ -272,6 +273,7 @@
 
             mCardInfoAvailable[i] = false;
             mIsNewCard[i] = false;
+            mRadioOn[i] = false;
         }
 
         mSubDeactivatedRegistrants = new RegistrantList[mNumPhones];
@@ -323,15 +325,21 @@
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE on SUB: " + subId);
-                mSetSubscriptionInProgress = false;
-                mSetDdsRequired = true;
+                mRadioOn[subId] = false;
+                if (!isAllRadioOn()) {
+                    mSetSubscriptionInProgress = false;
+                    mSetDdsRequired = true;
+                }
                 break;
 
             case EVENT_RADIO_ON:
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_ON on SUB: " + subId);
-                sendDefaultSubsInfo();
+                mRadioOn[subId] = true;
+                if (isAllRadioOn()) {
+                   sendDefaultSubsInfo();
+                }
                 break;
 
             case EVENT_CARD_INFO_AVAILABLE:
@@ -581,6 +589,10 @@
      * @param ar
      */
     private void processCleanupDataConnectionDone(Integer subId) {
+        if (!mRadioOn[subId]) {
+           logd("processCleanupDataConnectionDone: Radio Not Available on subId = " + subId);
+           return;
+        }
         // Cleanup data connection is done!  Start processing the
         // pending deactivate requests now.
         mDataActive = false;
@@ -599,6 +611,11 @@
         logd("processSubscriptionStatusChanged sub = " + subId
                 + " actStatus = " + actStatus);
 
+        if (!mRadioOn[subId]) {
+           logd("processSubscriptionStatusChanged: Radio Not Available on subId = " + subId);
+           return;
+        }
+
         if ((isSubReady == true && actStatus == SUB_STATUS_ACTIVATED) ||
                 (isSubReady == false && actStatus == SUB_STATUS_DEACTIVATED)) {
             logd("processSubscriptionStatusChanged: CurrentSubStatus and NewSubStatus are same" +
@@ -662,6 +679,12 @@
         SubscriptionStatus subStatus = SubscriptionStatus.SUB_INVALID;
         Subscription currentSub = null;
 
+        if (!mRadioOn[setSubParam.subId]) {
+           logd("processSetUiccSubscriptionDone: Radio Not Available on subId = "
+                + setSubParam.subId);
+           return;
+        }
+
         if (setSubParam.appType.equals("GLOBAL") &&
                 (setSubParam.subStatus == SubscriptionStatus.SUB_ACTIVATE)) {
             if ((mCardSubMgr.is3gppApp(setSubParam.subId, setSubParam.app3gppId)) &&
@@ -1000,6 +1023,10 @@
      * Handles EVENT_ALL_CARDS_INFO_AVAILABLE.
      */
     private void processAllCardsInfoAvailable() {
+        if (!isAllRadioOn()) {
+           logd("processAllCardsInfoAvailable: Radio Not Available ");
+           return;
+        }
         int availableCards = 0;
         mAllCardsStatusAvailable = true;
 
@@ -1028,6 +1055,10 @@
      * Handles EVENT_PROCESS_AVAILABLE_CARDS
      */
     private void processAvailableCards() {
+        if (!isAllRadioOn()) {
+           logd("processAvailableCards: Radio Not Available ");
+           return;
+        }
         if (mSetSubscriptionInProgress) {
            logd("processAvailableCards: set subscription in progress!!");
            return;
@@ -1144,6 +1175,11 @@
     private void processCardInfoAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
 
+        if (!mRadioOn[cardIndex]) {
+           logd("processCardInfoAvailable: Radio Not Available on cardIndex = " + cardIndex);
+           return;
+        }
+
         mCardInfoAvailable[cardIndex] = true;
 
         logd("processCardInfoAvailable: CARD:" + cardIndex + " is available");
@@ -1196,6 +1232,14 @@
         mContext.startActivity(setSubscriptionIntent);
     }
 
+    private boolean isAllRadioOn() {
+        boolean result = true;
+        for (boolean radioOn : mRadioOn) {
+            result = result && radioOn;
+        }
+        return result;
+    }
+
     private boolean isAllCardsInfoAvailable() {
         boolean result = true;
         for (boolean available : mCardInfoAvailable) {
diff -ur a/hardware/broadcom/libbt/src/userial_vendor.c b/hardware/broadcom/libbt/src/userial_vendor.c
--- a/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-06 00:00:00.000000000 +0000
+++ b/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-06 00:00:00.000000000 +0000
@@ -183,6 +183,10 @@
     uint16_t parity;
     uint8_t stop_bits;
 
+    #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+        int ldisc;
+    #endif
+
     vnd_userial.fd = -1;
 
     if (!userial_to_tcio_baud(p_cfg->baud, &baud))
@@ -252,6 +256,13 @@
     tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
 
 #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    // TODO: check for breakage on tuna (Galaxy Nexus). It defines this,
+    // but does not contain the kernel code to support it.
+
+    // Switch to N_BRCM_HCI line disclipline for ioctl to work
+    ldisc = 25; // N_BRCM_HCI
+    ioctl(vnd_userial.fd, TIOCSETD, &ldisc);
+
     userial_ioctl_init_bt_wake(vnd_userial.fd);
 #endif
 
diff -ur a/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java b/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java
--- a/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-06 00:00:00.000000000 +0000
+++ b/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-06 00:00:00.000000000 +0000
@@ -101,7 +101,6 @@
     private ListPreference mVoice;
     private ListPreference mData;
     private ListPreference mSms;
-    private PreferenceScreen mConfigSub;
     private CharSequence[] entries; // Used for entries like Subscription1, Subscription2 ...
     private CharSequence[] entryValues; // Used for entryValues like 0, 1 ,2 ...
     private CharSequence[] summaries; // Used for Summaries like Aubscription1, Subscription2....
@@ -142,8 +141,6 @@
         mData.setOnPreferenceChangeListener(this);
         mSms = (ListPreference) findPreference(KEY_SMS);
         mSms.setOnPreferenceChangeListener(this);
-        mConfigSub = (PreferenceScreen) findPreference(KEY_CONFIG_SUB);
-        mConfigSub.getIntent().putExtra(CONFIG_SUB, true);
         mTuneAway = (CheckBoxPreference) findPreference(TUNE_AWAY);
         mTuneAway.setOnPreferenceChangeListener(this);
         mPrioritySub = (ListPreference) findPreference(PRIORITY_SUB);
@@ -230,14 +227,9 @@
         Log.d(TAG, "mIccCardCount = " + mIccCardCount);
 
         if (mIccCardCount == 0) {
-             mConfigSub.setEnabled(false);
-             mConfigSub.setSelectable(false);
              displayAlertDialog(getResources().getString(R.string.no_sim_info));
              configureMSimMenu(false);
         } else if (mIccCardCount == 1) {
-             //1 SIM card is present. Config sub must be accessible
-             mConfigSub.setEnabled(true);
-             mConfigSub.setSelectable(true);
              configureMSimMenu(false);
         } else if ( (mIccCardCount > 1) && (mIccCardCount <= MAX_SUBSCRIPTIONS) )  {
             configureMSimMenu(true);
@@ -591,11 +583,6 @@
                     }
 
                     break;
-                case EVENT_SUBSCRIPTION_ACTIVATED:
-                case EVENT_SUBSCRIPTION_DEACTIVATED:
-                    updateMultiSimEntriesForVoice();
-                    updateMultiSimEntriesForSms();
-                    break;
 
                 case EVENT_SET_VOICE_SUBSCRIPTION:
                     if (!mHasTuneAway) {
diff -ur a/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java b/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
--- a/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-06 00:00:00.000000000 +0000
+++ b/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-06 00:00:00.000000000 +0000
@@ -60,6 +60,7 @@
 import android.provider.ContactsContract.CommonDataKinds;
 import android.provider.MediaStore;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.PhoneNumberUtils;
 import android.text.TextUtils;
 import android.util.Log;
@@ -2693,10 +2694,15 @@
      * This is useful for implementing "HomeAsUp" capability for second-level Settings.
      */
     public static void goUpToTopLevelSetting(Activity activity) {
-        Intent intent = new Intent(activity, CallFeaturesSetting.class);
-        intent.setAction(Intent.ACTION_MAIN);
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-        activity.startActivity(intent);
+         if (!MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            // HACK: This doesn't work on multi-SIM (and we have multiple)
+            //       hierachy (MSimCallFeaturesSetting and MSimCallFeatureSubSetting)
+            //       so let just allow this to act like "back" button
+            Intent intent = new Intent(activity, CallFeaturesSetting.class);
+            intent.setAction(Intent.ACTION_MAIN);
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            activity.startActivity(intent);
+        }
         activity.finish();
     }
 
diff -ur a/external/tinyalsa/include/tinyalsa/asoundlib.h b/external/tinyalsa/include/tinyalsa/asoundlib.h
--- a/external/tinyalsa/include/tinyalsa/asoundlib.h	2016-05-25 10:17:32.620000000 +0000
+++ b/external/tinyalsa/include/tinyalsa/asoundlib.h	2016-05-25 10:17:43.408000000 +0000
@@ -204,6 +204,7 @@
 
 /* Start and stop a PCM channel that doesn't transfer data */
 int pcm_start(struct pcm *pcm);
+int pcm_drain(struct pcm *pcm);
 int pcm_stop(struct pcm *pcm);
 
 /* ioctl function for PCM driver */
diff -ur a/external/tinyalsa/pcm.c b/external/tinyalsa/pcm.c
--- a/external/tinyalsa/pcm.c	2016-05-25 10:17:32.620000000 +0000
+++ b/external/tinyalsa/pcm.c	2016-05-25 10:17:43.412000000 +0000
@@ -788,6 +788,14 @@
     return 0;
 }
 
+int pcm_drain(struct pcm *pcm)
+{
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DRAIN) < 0)
+        return oops(pcm, errno, "drain failed");
+
+    return 0;
+}
+
 int pcm_stop(struct pcm *pcm)
 {
     if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_DROP) < 0)


diff -ur a/build/core/tasks/kernel.mk b/build/core/tasks/kernel.mk
--- a/build/core/tasks/kernel.mk	2016-02-15 14:15:26.040779000 +0000
+++ b/build/core/tasks/kernel.mk	2016-02-15 14:44:40.620779000 +0000
@@ -202,7 +202,11 @@
     ccache := $(strip $(wildcard $(ccache)))
 endif
 
-KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+ifneq ($(TARGET_KERNEL_CUSTOM_TOOLCHAIN),)     
+    KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilts/gcc/linux-x86/arm/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"      
+else
+    KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+endif
 ccache =
 
 define mv-modules
diff -ur a/external/icu/icu4c/source/common/ucnv.c b/external/icu/icu4c/source/common/ucnv.c
--- a/external/icu/icu4c/source/common/ucnv.c	2016-02-15 14:15:34.788779000 +0000
+++ b/external/icu/icu4c/source/common/ucnv.c	2016-02-15 14:44:40.624779000 +0000
@@ -2914,6 +2914,76 @@
             return FALSE;
     }
 }
+
+U_CAPI void    U_EXPORT2 ucnv_setToUCallBack_48 (UConverter * converter,
+                            UConverterToUCallback newAction,
+                            const void* newContext,
+                            UConverterToUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+  ucnv_setToUCallBack(converter, newAction, newContext,
+        oldAction, oldContext, err);
+}
+
+U_CAPI void  U_EXPORT2 ucnv_close_48 (UConverter * converter) {
+  ucnv_close (converter);
+}
+
+U_CAPI void  U_EXPORT2
+ucnv_setFromUCallBack_48 (UConverter * converter,
+                            UConverterFromUCallback newAction,
+                            const void* newContext,
+                            UConverterFromUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+
+  ucnv_setFromUCallBack(converter, newAction, newContext, oldAction,
+        oldContext, err);
+}
+
+U_CAPI void U_EXPORT2
+ucnv_convertEx_48 (UConverter *targetCnv, UConverter *sourceCnv,
+               char **target, const char *targetLimit,
+               const char **source, const char *sourceLimit,
+               UChar *pivotStart, UChar **pivotSource,
+               UChar **pivotTarget, const UChar *pivotLimit,
+               UBool reset, UBool flush,
+               UErrorCode *pErrorCode) {
+  ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source,
+        sourceLimit, pivotStart, pivotSource,
+        pivotTarget, pivotLimit, reset, flush,
+        pErrorCode);
+}
+
+U_CAPI UConverter* U_EXPORT2
+ucnv_open_48 (const char *name,
+                       UErrorCode * err) {
+  return ucnv_open(name, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_FROM_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterFromUnicodeArgs *fromUArgs,
+                  const UChar* codeUnits,
+                  int32_t length,
+                  UChar32 codePoint,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits,
+      length, codePoint, reason, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_TO_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterToUnicodeArgs *toUArgs,
+                  const char* codeUnits,
+                  int32_t length,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length,
+      reason, err);
+}
+
 #endif
 
 /*
diff -ur a/external/sepolicy/domain.te b/external/sepolicy/domain.te
--- a/external/sepolicy/domain.te	2016-02-15 14:15:32.456779000 +0000
+++ b/external/sepolicy/domain.te	2016-02-15 14:44:40.624779000 +0000
@@ -236,7 +232,7 @@
 # init starts in kernel domain and switches to init domain via setcon in
 # the init.rc, so the setenforce occurs while still in kernel. After
 # switching domains, there is never any need to setenforce again by init.
-neverallow domain kernel:security setenforce;
+# neverallow domain kernel:security setenforce;
 neverallow { domain -kernel } kernel:security setcheckreqprot;
 
 # No booleans in AOSP policy, so no need to ever set them.
@@ -323,11 +319,7 @@
 
 # Restrict context mounts to specific types marked with
 # the contextmount_type attribute.
-ifelse(shipping_build, `true',
-  `neverallow domain {fs_type -contextmount_type}:filesystem relabelto;'
-,
-  `neverallow domain {fs_type -contextmount_type -sdcard_posix}:filesystem relabelto;'
-)
+neverallow domain {fs_type -contextmount_type -sdcard_posix}:filesystem relabelto;
 
 # Ensure that context mount types are not writable, to ensure that
 # the write to /system restriction above is not bypassed via context=
diff -ur a/frameworks/av/include/media/stagefright/ColorConverter.h b/frameworks/av/include/media/stagefright/ColorConverter.h
--- a/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-15 14:14:34.156779000 +0000
+++ b/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-15 14:44:40.624779000 +0000
@@ -67,6 +67,9 @@
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
 
+    status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);
+
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff -ur a/frameworks/av/media/libstagefright/ACodec.cpp b/frameworks/av/media/libstagefright/ACodec.cpp
--- a/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-15 14:14:34.100779000 +0000
+++ b/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-15 14:44:40.628779000 +0000
@@ -777,6 +777,7 @@
 }
 
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
+    ALOGE("ACodec:PATCH:allocateBuffersOnPort portIndex(%i)", portIndex);
     CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);
 
     CHECK(mDealer[portIndex] == NULL);
@@ -784,20 +785,21 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (storingMetadataInDecodedBuffers()) {
-            err = allocateOutputMetadataBuffers();
-        } else {
+            ALOGE("ACodec:PATCH:allocateBuffersOnPort portIndex(%i) -> allocateOutputBuffersFromNativeWindow()", portIndex);
             err = allocateOutputBuffersFromNativeWindow();
-        }
     } else {
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort ELSE (%i)", portIndex);
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
         def.nPortIndex = portIndex;
 
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort ELSE def.nPortIndex(%i) portIndex(%i)", def.nPortIndex, portIndex);
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort getParameter(OMX_IndexParamPortDefinition) (%i) (%i)", def.nPortIndex, portIndex);
         err = mOMX->getParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
         if (err == OK) {
+            ALOGE("ACodec:PATCH:allocateBuffersOnPort getParameter(OMX_IndexParamPortDefinition) OK (%i) (%i)", def.nPortIndex, portIndex);
             MetadataBufferType type =
                 portIndex == kPortIndexOutput ? mOutputMetadataType : mInputMetadataType;
             int32_t bufSize = def.nBufferSize;
@@ -865,9 +867,11 @@
                 mBuffers[portIndex].push(info);
             }
         }
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort getParameter(OMX_IndexParamPortDefinition) ERROR? (%i) (%i)", def.nPortIndex, portIndex);
     }
 
     if (err != OK) {
+        ALOGE("ACodec:PATCH:allocateBuffersOnPort ERROR (%i)", portIndex);
         return err;
     }
 
@@ -875,6 +879,7 @@
     notify->setInt32("what", CodecBase::kWhatBuffersAllocated);
 
     notify->setInt32("portIndex", portIndex);
+    ALOGE("ACodec:PATCH:allocateBuffersOnPort setInt32(portIndex)(%i)", portIndex);
 
     sp<PortDescription> desc = new PortDescription;
 
@@ -892,14 +897,17 @@
 
 status_t ACodec::setupNativeWindowSizeFormatAndUsage(
         ANativeWindow *nativeWindow /* nonnull */, int *finalUsage /* nonnull */) {
+    ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s]", mComponentName.c_str());
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
+    ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.nPortIndex = %i", mComponentName.c_str(), def.nPortIndex);
 
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
     if (err != OK) {
+        ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] getParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
         return err;
     }
 
@@ -924,6 +932,20 @@
     setNativeWindowColorFormat(eNativeColorFormat);
 #endif
 
+    ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat(%i)", mComponentName.c_str(), def.format.video.eColorFormat);
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:{
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+            ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat NOW (%i)", mComponentName.c_str(), def.format.video.eColorFormat);
+        }
+        break;
+        default:
+            ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat Default (%i) (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12", mComponentName.c_str(), (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+    }
+
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
     err = setNativeWindowSizeFormatAndUsage(
             nativeWindow,
@@ -932,7 +954,7 @@
 #ifdef USE_SAMSUNG_COLORFORMAT
             eNativeColorFormat,
 #else
-            def.format.video.eColorFormat,
+            HalColorFormat,
 #endif
             mRotationDegrees,
             usage);
@@ -961,6 +983,7 @@
 status_t ACodec::configureOutputBuffersFromNativeWindow(
         OMX_U32 *bufferCount, OMX_U32 *bufferSize,
         OMX_U32 *minUndequeuedBuffers) {
+    ALOGE("ACodec:PATCH:configureOutputBuffersFromNativeWindow[%s]", mComponentName.c_str());
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
@@ -972,6 +995,7 @@
         err = setupNativeWindowSizeFormatAndUsage(mNativeWindow.get(), &mNativeWindowUsageBits);
     }
     if (err != OK) {
+        ALOGE("ACodec:PATCH:configureOutputBuffersFromNativeWindow[%s] getParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
         mNativeWindowUsageBits = 0;
         return err;
     }
@@ -1694,8 +1718,10 @@
 
 status_t ACodec::configureCodec(
         const char *mime, const sp<AMessage> &msg) {
+    ALOGE("ACodec:PATCH:configureCodec[%s]", mComponentName.c_str());
     int32_t encoder;
     if (!msg->findInt32("encoder", &encoder)) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] not encoder", mComponentName.c_str());
         encoder = false;
     }
 
@@ -1710,6 +1736,7 @@
     status_t err = setComponentRole(encoder /* isEncoder */, mime);
 
     if (err != OK) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] setComponentRole ERROR", mComponentName.c_str());
         return err;
     }
 
@@ -1726,6 +1753,7 @@
     if (encoder
             && msg->findInt32("store-metadata-in-buffers", &storeMeta)
             && storeMeta != 0) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] storeMetaDataInBuffers", mComponentName.c_str());
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE, &mInputMetadataType);
         if (err != OK) {
             ALOGE("[%s] storeMetaDataInBuffers (input) failed w/ err %d",
@@ -1736,16 +1764,11 @@
         // For this specific case we could be using camera source even if storeMetaDataInBuffers
         // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
         if (mInputMetadataType == kMetadataBufferTypeGrallocSource) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] mInputMetadataType == kMetadataBufferTypeGrallocSource", mComponentName.c_str());
             mInputMetadataType = kMetadataBufferTypeCameraSource;
         }
 
-        uint32_t usageBits;
-        if (mOMX->getParameter(
-                mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
-                &usageBits, sizeof(usageBits)) == OK) {
-            inputFormat->setInt32(
-                    "using-sw-read-often", !!(usageBits & GRALLOC_USAGE_SW_READ_OFTEN));
-        }
+        ALOGE("ACodec:PATCH:configureCodec[%s] BEGIN using-sw-read-often", mComponentName.c_str());
     }
 
     int32_t prependSPSPPS = 0;
@@ -1753,6 +1776,7 @@
             && msg->findInt32("prepend-sps-pps-to-idr-frames", &prependSPSPPS)
             && prependSPSPPS != 0) {
         OMX_INDEXTYPE index;
+        ALOGE("ACodec:PATCH:configureCodec[%s] getExtensionIndex OMX.google.android.index.prependSPSPPSToIDRFrames", mComponentName.c_str());
         err = mOMX->getExtensionIndex(
                 mNode,
                 "OMX.google.android.index.prependSPSPPSToIDRFrames",
@@ -1784,7 +1808,7 @@
         OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS
             && msg->findInt32("store-metadata-in-buffers-output", &storeMeta)
             && storeMeta != 0);
-
+        ALOGE("ACodec:PATCH:configureCodec[%s] storeMetaDataInBuffers 2", mComponentName.c_str());
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, enable, &mOutputMetadataType);
         if (err != OK) {
             ALOGE("[%s] storeMetaDataInBuffers (output) failed w/ err %d",
@@ -1794,28 +1818,33 @@
         if (!msg->findInt64(
                     "repeat-previous-frame-after",
                     &mRepeatFrameDelayUs)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] repeat-previous-frame-after ERROR", mComponentName.c_str());
             mRepeatFrameDelayUs = -1ll;
         }
 
         if (!msg->findInt64("max-pts-gap-to-encoder", &mMaxPtsGapUs)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] max-pts-gap-to-encoder ERROR", mComponentName.c_str());
             mMaxPtsGapUs = -1ll;
         }
 
         if (!msg->findFloat("max-fps-to-encoder", &mMaxFps)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] max-fps-to-encoder ERROR", mComponentName.c_str());
             mMaxFps = -1;
         }
 
         if (!msg->findInt64("time-lapse", &mTimePerCaptureUs)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] time-lapse ERROR", mComponentName.c_str());
             mTimePerCaptureUs = -1ll;
         }
 
         if (!msg->findInt32(
                     "create-input-buffers-suspended",
                     (int32_t*)&mCreateInputBuffersSuspended)) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] create-input-buffers-suspended false", mComponentName.c_str());
             mCreateInputBuffersSuspended = false;
         }
     }
-
+    ALOGE("ACodec:PATCH:configureCodec[%s] 2", mComponentName.c_str());
     // NOTE: we only use native window for video decoders
     sp<RefBase> obj;
     bool haveNativeWindow = msg->findObject("native-window", &obj)
@@ -1837,7 +1866,7 @@
     if (haveNativeWindow) {
         sp<ANativeWindow> nativeWindow =
             static_cast<ANativeWindow *>(static_cast<Surface *>(obj.get()));
-
+        ALOGE("ACodec:PATCH:configureCodec[%s] 3", mComponentName.c_str());
         // START of temporary support for automatic FRC - THIS WILL BE REMOVED
         int32_t autoFrc;
         if (msg->findInt32("auto-frc", &autoFrc)) {
@@ -1855,13 +1884,13 @@
             }
         }
         // END of temporary support for automatic FRC
-
+        ALOGE("ACodec:PATCH:configureCodec[%s] 4", mComponentName.c_str());
         int32_t tunneled;
         if (msg->findInt32("feature-tunneled-playback", &tunneled) &&
             tunneled != 0) {
             ALOGI("Configuring TUNNELED video playback.");
             mTunneled = true;
-
+            ALOGE("ACodec:PATCH:configureCodec[%s] 5", mComponentName.c_str());
             int32_t audioHwSync = 0;
             if (!msg->findInt32("audio-hw-sync", &audioHwSync)) {
                 ALOGW("No Audio HW Sync provided for video tunnel");
@@ -1885,12 +1914,14 @@
                     // allow failure
                     err = OK;
                 } else {
+                    ALOGE("ACodec:PATCH:configureCodec[%s] 6", mComponentName.c_str());
                     inputFormat->setInt32("max-width", maxWidth);
                     inputFormat->setInt32("max-height", maxHeight);
                     inputFormat->setInt32("adaptive-playback", true);
                 }
             }
         } else {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 7", mComponentName.c_str());
             ALOGV("Configuring CPU controlled video playback.");
             mTunneled = false;
 
@@ -1904,6 +1935,7 @@
             }
 
             // Always try to enable dynamic output buffers on native surface
+            ALOGE("ACodec:PATCH:configureCodec[%s] 8", mComponentName.c_str());
             err = mOMX->storeMetaDataInBuffers(
                     mNode, kPortIndexOutput, OMX_TRUE, &mOutputMetadataType);
             if (err != OK) {
@@ -1953,8 +1985,10 @@
                     }
                 }
                 // allow failure
+                ALOGE("ACodec:PATCH:configureCodec[%s] 9", mComponentName.c_str());
                 err = OK;
             } else {
+                ALOGE("ACodec:PATCH:configureCodec[%s] 10", mComponentName.c_str());
                 ALOGV("[%s] storeMetaDataInBuffers succeeded",
                         mComponentName.c_str());
                 CHECK(storingMetadataInDecodedBuffers());
@@ -1965,6 +1999,7 @@
             }
 
             int32_t push;
+            ALOGE("ACodec:PATCH:configureCodec[%s] 11", mComponentName.c_str());
             if (msg->findInt32("push-blank-buffers-on-shutdown", &push)
                     && push != 0) {
                 mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
@@ -1972,6 +2007,7 @@
         }
 
         int32_t rotationDegrees;
+        ALOGE("ACodec:PATCH:configureCodec[%s] 12", mComponentName.c_str());
         if (msg->findInt32("rotation-degrees", &rotationDegrees)) {
             mRotationDegrees = rotationDegrees;
         } else {
@@ -1980,6 +2016,7 @@
     }
 
     if (video) {
+        ALOGE("ACodec:PATCH:configureCodec[%s] 13", mComponentName.c_str());
         // determine need for software renderer
         bool usingSwRenderer = false;
         if (haveNativeWindow && (mComponentName.startsWith("OMX.google.") ||
@@ -1989,28 +2026,35 @@
         }
 
         if (encoder) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 14", mComponentName.c_str());
             err = setupVideoEncoder(mime, msg);
         } else {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 15", mComponentName.c_str());
             err = setupVideoDecoder(mime, msg, haveNativeWindow);
         }
 
         if (err != OK) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 16", mComponentName.c_str());
             return err;
         }
 
         if (haveNativeWindow) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 17", mComponentName.c_str());
             mNativeWindow = static_cast<Surface *>(obj.get());
         }
 
         // initialize native window now to get actual output format
         // TODO: this is needed for some encoders even though they don't use native window
         err = initNativeWindow();
+        ALOGE("ACodec:PATCH:configureCodec[%s] 18", mComponentName.c_str());
         if (err != OK) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 19", mComponentName.c_str());
             return err;
         }
 
         // fallback for devices that do not handle flex-YUV for native buffers
         if (haveNativeWindow) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 20", mComponentName.c_str());
             int32_t requestedColorFormat = OMX_COLOR_FormatUnused;
             if (msg->findInt32("color-format", &requestedColorFormat) &&
                     requestedColorFormat == OMX_COLOR_FormatYUV420Flexible) {
@@ -2058,6 +2102,7 @@
         }
 
         if (usingSwRenderer) {
+            ALOGE("ACodec:PATCH:configureCodec[%s] 21", mComponentName.c_str());
             outputFormat->setInt32("using-sw-renderer", 1);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
@@ -2247,20 +2292,23 @@
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
     }
 
-    int32_t priority;
-    if (msg->findInt32("priority", &priority)) {
-        err = setPriority(priority);
-    }
+    ALOGE("ACodec:PATCH:configureCodec[%s] skip setPriority", mComponentName.c_str());
 
-    int32_t rateInt = -1;
-    float rateFloat = -1;
-    if (!msg->findFloat("operating-rate", &rateFloat)) {
-        msg->findInt32("operating-rate", &rateInt);
-        rateFloat = (float)rateInt;  // 16MHz (FLINTMAX) is OK for upper bound.
-    }
-    if (rateFloat > 0) {
-        err = setOperatingRate(rateFloat, video);
-    }
+    //int32_t priority;
+    //if (msg->findInt32("priority", &priority)) {
+    //    err = setPriority(priority);
+    //}
+
+    ALOGE("ACodec:PATCH:configureCodec[%s] skip setOperatingRate", mComponentName.c_str());
+    //int32_t rateInt = -1;
+    //float rateFloat = -1;
+    //if (!msg->findFloat("operating-rate", &rateFloat)) {
+    //    msg->findInt32("operating-rate", &rateInt);
+    //    rateFloat = (float)rateInt;  // 16MHz (FLINTMAX) is OK for upper bound.
+    //}
+    //if (rateFloat > 0) {
+    //    err = setOperatingRate(rateFloat, video);
+    //}
 
     mBaseOutputFormat = outputFormat;
 
@@ -2798,6 +2846,7 @@
         OMX_VIDEO_CODINGTYPE compressionFormat,
         OMX_COLOR_FORMATTYPE colorFormat,
         bool usingNativeBuffers) {
+    ALOGE("ACodec:PATCH:setVideoPortFormatType[%s]", mComponentName.c_str());
     OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = portIndex;
@@ -2807,11 +2856,13 @@
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
+        ALOGE("ACodec:PATCH:setVideoPortFormatType[%s] getParameter(OMX_IndexParamVideoPortFormat)", mComponentName.c_str());
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
 
         if (err != OK) {
+            ALOGE("ACodec:PATCH:setVideoPortFormatType[%s] getParameter(OMX_IndexParamVideoPortFormat) ERROR", mComponentName.c_str());
             return err;
         }
 
@@ -2821,7 +2872,7 @@
                 && isFlexibleColorFormat(
                         mOMX, mNode, format.eColorFormat, usingNativeBuffers, &flexibleEquivalent)
                 && colorFormat == flexibleEquivalent) {
-            ALOGI("[%s] using color format %#x in place of %#x",
+            ALOGE("[%s] using color format %#x in place of %#x",
                     mComponentName.c_str(), format.eColorFormat, colorFormat);
             colorFormat = format.eColorFormat;
         }
@@ -2854,6 +2905,7 @@
     }
 
     if (!found) {
+        ALOGE("ACodec:PATCH:setVideoPortFormatType[%s] UNKNOWN_ERROR", mComponentName.c_str());
         return UNKNOWN_ERROR;
     }
 
@@ -2879,6 +2931,7 @@
 // For legacy support, we prefer a standard format, but will settle for a SW readable
 // flex-YUV format.
 status_t ACodec::setSupportedOutputFormat(bool getLegacyFlexibleFormat) {
+    ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s]", mComponentName.c_str());
     OMX_VIDEO_PARAM_PORTFORMATTYPE format, legacyFormat;
     InitOMXParams(&format);
     format.nPortIndex = kPortIndexOutput;
@@ -2889,10 +2942,12 @@
 
     for (OMX_U32 index = 0; ; ++index) {
         format.nIndex = index;
+        ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat)", mComponentName.c_str());
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
         if (err != OK) {
+            ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) ERROR", mComponentName.c_str());
             // no more formats, pick legacy format if found
             if (legacyFormat.eColorFormat != OMX_COLOR_FormatUnused) {
                  memcpy(&format, &legacyFormat, sizeof(format));
@@ -2924,6 +2979,7 @@
             memcpy(&legacyFormat, &format, sizeof(format));
         }
     }
+    ALOGE("ACodec:PATCH:setSupportedOutputFormat[%s] setParameter(OMX_IndexParamVideoPortFormat)", mComponentName.c_str());
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -2977,6 +3033,7 @@
 
 status_t ACodec::setupVideoDecoder(
         const char *mime, const sp<AMessage> &msg, bool haveNativeWindow) {
+    ALOGE("ACodec:PATCH:setupVideoDecoder[%s]", mComponentName.c_str());
     int32_t width, height;
     if (!msg->findInt32("width", &width)
             || !msg->findInt32("height", &height)) {
@@ -3004,11 +3061,15 @@
     if (msg->findInt32("color-format", &tmp)) {
         OMX_COLOR_FORMATTYPE colorFormat =
             static_cast<OMX_COLOR_FORMATTYPE>(tmp);
+
+        ALOGE("ACodec:PATCH:setupVideoDecoder[%s] colorFormat = %i", mComponentName.c_str(), colorFormat);
+
         err = setVideoPortFormatType(
                 kPortIndexOutput, OMX_VIDEO_CodingUnused, colorFormat, haveNativeWindow);
         if (err != OK) {
             ALOGW("[%s] does not support color format %d",
                   mComponentName.c_str(), colorFormat);
+            ALOGE("ACodec:PATCH:setupVideoDecoder[%s] setSupportedOutputFormat", mComponentName.c_str());
             err = setSupportedOutputFormat(!haveNativeWindow /* getLegacyFlexibleFormat */);
         }
     } else {
@@ -3046,6 +3107,7 @@
 }
 
 status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
+    ALOGE("ACodec:PATCH:setupVideoEncoder");
     int32_t tmp;
     if (!msg->findInt32("color-format", &tmp)) {
         return INVALID_OPERATION;
@@ -3054,6 +3116,8 @@
     OMX_COLOR_FORMATTYPE colorFormat =
         static_cast<OMX_COLOR_FORMATTYPE>(tmp);
 
+    ALOGE("ACodec:PATCH:setupVideoEncoder colorFormat = %i", colorFormat);
+
     status_t err = setVideoPortFormatType(
             kPortIndexInput, OMX_VIDEO_CodingUnused, colorFormat);
 
@@ -3210,7 +3274,7 @@
     }
 
     if (err == OK) {
-        ALOGI("setupVideoEncoder succeeded");
+        ALOGE("setupVideoEncoder succeeded");
     }
 
     return err;
@@ -3736,6 +3800,7 @@
 
 status_t ACodec::verifySupportForProfileAndLevel(
         int32_t profile, int32_t level) {
+    ALOGE("ACodec:PATCH:verifySupportForProfileAndLevel[%s] profile[%i] level[%i]", mComponentName.c_str(), profile, level);
     OMX_VIDEO_PARAM_PROFILELEVELTYPE params;
     InitOMXParams(&params);
     params.nPortIndex = kPortIndexOutput;
@@ -3748,6 +3813,7 @@
                 sizeof(params));
 
         if (err != OK) {
+            ALOGE("ACodec:PATCH:verifySupportForProfileAndLevel[%s] getParameter(OMX_IndexParamVideoProfileLevelQuerySupported) ERROR", mComponentName.c_str());
             return err;
         }
 
@@ -3810,15 +3876,18 @@
         OMX_U32 portIndex,
         int32_t width, int32_t height, OMX_VIDEO_CODINGTYPE compressionFormat,
         float frameRate) {
+    ALOGE("ACodec:PATCH:setVideoFormatOnPort");
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
     OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
 
+    ALOGE("ACodec:PATCH:setVideoFormatOnPort getParameter(OMX_IndexParamPortDefinition)");
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     if (err != OK) {
+        ALOGE("ACodec:PATCH:setVideoFormatOnPort getParameter(OMX_IndexParamPortDefinition) ERROR");
         return err;
     }
 
@@ -3846,6 +3915,7 @@
         }
     }
 
+    ALOGE("ACodec:PATCH:setVideoFormatOnPort setParameter(OMX_IndexParamPortDefinition)");
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -3941,6 +4011,7 @@
 
 // static
 bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
+    ALOGE("ACodec:PATCH:describeDefaultColorFormat");
     MediaImage &image = params.sMediaImage;
     memset(&image, 0, sizeof(image));
 
@@ -3948,6 +4019,20 @@
     image.mNumPlanes = 0;
 
     const OMX_COLOR_FORMATTYPE fmt = params.eColorFormat;
+
+    ALOGE("ACodec:PATCH:describeDefaultColorFormat eColorFormat = %i", params.eColorFormat);
+
+    switch(params.eColorFormat){
+        case OMX_COLOR_FormatYCbYCr:{
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat eColorFormat = %i SET to %i", params.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            params.eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        }
+        break;
+        default:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat default eColorFormat = %i", params.eColorFormat);
+        break;
+    }
+
     image.mWidth = params.nFrameWidth;
     image.mHeight = params.nFrameHeight;
 
@@ -3988,7 +4073,9 @@
 
     switch ((int)fmt) {
         case HAL_PIXEL_FORMAT_YV12:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat case HAL_PIXEL_FORMAT_YV12 (%i)", HAL_PIXEL_FORMAT_YV12);
             if (params.bUsingNativeBuffers) {
+                ALOGE("ACodec:PATCH:describeDefaultColorFormat case HAL_PIXEL_FORMAT_YV12 (%i) bUsingNativeBuffers", HAL_PIXEL_FORMAT_YV12);
                 size_t ystride = align(params.nStride, 16);
                 size_t cstride = align(params.nStride / 2, 16);
                 image.mPlane[image.Y].mRowInc = ystride;
@@ -4007,11 +4094,13 @@
                 image.mPlane[image.U].mVertSubsampling = 2;
                 break;
             } else {
+                ALOGE("ACodec:PATCH:describeDefaultColorFormat case HAL_PIXEL_FORMAT_YV12 (%i) ERROR", HAL_PIXEL_FORMAT_YV12);
                 // fall through as YV12 is used for YUV420Planar by some codecs
             }
 
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatYUV420PackedPlanar:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat case OMX_COLOR_FormatYUV420Planar (%i) or OMX_COLOR_FormatYUV420PackedPlanar (%i)", OMX_COLOR_FormatYUV420Planar, OMX_COLOR_FormatYUV420PackedPlanar);
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 1;
             image.mPlane[image.U].mRowInc = params.nStride / 2;
@@ -4030,6 +4119,7 @@
             // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
         case OMX_COLOR_FormatYUV420PackedSemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+            ALOGE("ACodec:PATCH:describeDefaultColorFormat case OMX_COLOR_FormatYUV420SemiPlanar (%i) or OMX_COLOR_FormatYUV420PackedSemiPlanar (%i) or OMX_TI_COLOR_FormatYUV420PackedSemiPlanar (%i)", OMX_COLOR_FormatYUV420SemiPlanar, OMX_COLOR_FormatYUV420PackedSemiPlanar, OMX_TI_COLOR_FormatYUV420PackedSemiPlanar);
             // NV12
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 2;
@@ -4055,6 +4145,7 @@
         const sp<IOMX> &omx, IOMX::node_id node,
         DescribeColorFormatParams &describeParams)
 {
+    ALOGE("ACodec:PATCH:describeColorFormat");
     OMX_INDEXTYPE describeColorFormatIndex;
     if (omx->getExtensionIndex(
             node, "OMX.google.android.index.describeColorFormat",
@@ -4064,6 +4155,7 @@
             &describeParams, sizeof(describeParams)) != OK) {
         return describeDefaultColorFormat(describeParams);
     }
+    ALOGE("ACodec:PATCH:describeColorFormat MediaImage::MEDIA_IMAGE_TYPE_UNKNOWN");
     return describeParams.sMediaImage.mType !=
             MediaImage::MEDIA_IMAGE_TYPE_UNKNOWN;
 }
@@ -4112,13 +4204,16 @@
 }
 
 status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
+    ALOGE("ACodec:PATCH:getPortFormat[%s]", mComponentName.c_str());
     const char *niceIndex = portIndex == kPortIndexInput ? "input" : "output";
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
+    ALOGE("ACodec:PATCH:getPortFormat[%s] getParameter(OMX_IndexParamPortDefinition)", mComponentName.c_str());
     status_t err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     if (err != OK) {
+        ALOGE("ACodec:PATCH:getPortFormat[%s] getParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
         return err;
     }
 
@@ -5843,8 +5938,10 @@
     AString mime;
 
     if (!msg->findString("mime", &mime)) {
+        ALOGE("ACodec:PATCH:onConfigureComponent MIME BAD_VALUE");
         err = BAD_VALUE;
     } else {
+        ALOGE("ACodec:PATCH:onConfigureComponent configureCodec [%s]", mCodec->mComponentName.c_str());
         err = mCodec->configureCodec(mime.c_str(), msg);
     }
     if (err != OK) {
@@ -5912,6 +6009,7 @@
             observer->setNotificationMessage(notify);
             mCodec->mComponentName = componentName;
 
+            ALOGE("ACodec:PATCH:onConfigureComponent configureCodec2 [%s]", mCodec->mComponentName.c_str());
             err = mCodec->configureCodec(mime.c_str(), msg);
         }
 
@@ -6564,14 +6662,15 @@
         }
     }
 
-    float rate;
-    if (params->findFloat("operating-rate", &rate) && rate > 0) {
-        status_t err = setOperatingRate(rate, mIsVideo);
-        if (err != OK) {
-            ALOGE("Failed to set parameter 'operating-rate' (err %d)", err);
-            return err;
-        }
-    }
+    ALOGE("ACodec:PATCH:setParameters skip operating-rate");
+    //float rate;
+    //if (params->findFloat("operating-rate", &rate) && rate > 0) {
+    //    status_t err = setOperatingRate(rate, mIsVideo);
+    //    if (err != OK) {
+    //        ALOGE("Failed to set parameter 'operating-rate' (err %d)", err);
+    //        return err;
+    //    }
+    //}
 
     return OK;
 }
diff -ur a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
--- a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-15 14:14:34.088779000 +0000
+++ b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-15 14:44:40.632779000 +0000
@@ -44,6 +44,7 @@
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+        case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -110,6 +111,10 @@
             err = convertCbYCrY(src, dst);
             break;
 
+        case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break;
+
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
             break;
@@ -159,6 +164,71 @@
 
             signed u_b = u * 517;
             signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+        ALOGE("PATCH:ColorConverter:convertYCbYCr");
+    // XXX Untested
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+            signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
             signed v_g = -v * 208;
             signed v_r = v * 409;
 
diff -ur a/frameworks/av/media/libstagefright/MPEG4Writer.cpp b/frameworks/av/media/libstagefright/MPEG4Writer.cpp
--- a/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-02-15 14:14:34.088779000 +0000
+++ b/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-02-15 14:44:40.632779000 +0000
@@ -2202,6 +2202,7 @@
 }
 
 status_t MPEG4Writer::Track::threadEntry() {
+    ALOGE("MPEG4Writer:PATCH:threadEntry");
     int32_t count = 0;
     const int64_t interleaveDurationUs = mOwner->interleaveDuration();
     const bool hasMultipleTracks = (mOwner->numTracks() > 1);
@@ -2229,6 +2230,7 @@
     }
 
     if (mOwner->isRealTimeRecording()) {
+        ALOGE("MPEG4Writer:PATCH:threadEntry ANDROID_PRIORITY_AUDIO");
         androidSetThreadPriority(0, ANDROID_PRIORITY_AUDIO);
     }
 
@@ -2356,8 +2358,7 @@
 
         timestampUs -= previousPausedDurationUs;
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 1");
         }
 
         if (!mIsAudio) {
@@ -2372,8 +2373,7 @@
             cttsOffsetTimeUs =
                     timestampUs - decodingTimeUs;
             if (WARN_UNLESS(kMaxCttsOffsetTimeUs >= decodingTimeUs - timestampUs, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 2");
             }
 
             timestampUs = decodingTimeUs;
@@ -2384,8 +2384,7 @@
             currCttsOffsetTimeTicks =
                     (cttsOffsetTimeUs * mTimeScale + 500000LL) / 1000000LL;
             if (WARN_UNLESS(currCttsOffsetTimeTicks <= 0x0FFFFFFFFLL, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 3");
             }
 
             if (mStszTableEntries->count() == 0) {
@@ -2426,8 +2425,7 @@
         }
 
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 4");
         }
 
         ALOGV("%s media time stamp: %" PRId64 " and previous paused duration %" PRId64,
@@ -2447,8 +2445,7 @@
         if (currDurationTicks < 0ll) {
             ALOGE("timestampUs %" PRId64 " < lastTimestampUs %" PRId64 " for %s track",
                 timestampUs, lastTimestampUs, trackName);
-            copy->release();
-            return UNKNOWN_ERROR;
+            ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 5");
         }
 
         // if the duration is different for this sample, see if it is close enough to the previous
@@ -2546,7 +2543,7 @@
     }
 
     if (isTrackMalFormed()) {
-        err = ERROR_MALFORMED;
+        ALOGE("MPEG4Writer:PATCH:threadEntry ERROR_MALFORMED 6");
     }
 
     mOwner->trackProgressStatus(mTrackId, -1, err);
diff -ur a/frameworks/av/media/libstagefright/OMXCodec.cpp b/frameworks/av/media/libstagefright/OMXCodec.cpp
--- a/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-15 14:14:33.844779000 +0000
+++ b/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-15 14:44:40.636779000 +0000
@@ -347,7 +347,7 @@
                 InstantiateSoftwareEncoder(componentName, source, meta);
 
             if (softwareCodec != NULL) {
-                ALOGV("Successfully allocated software codec '%s'", componentName);
+                ALOGE("Successfully allocated software codec '%s'", componentName);
 
                 return softwareCodec;
             }
@@ -372,7 +372,7 @@
 
         status_t err = omx->allocateNode(componentName, observer, &node);
         if (err == OK) {
-            ALOGV("Successfully allocated OMX node '%s'", componentName);
+            ALOGE("Successfully allocated OMX node '%s'", componentName);
 
             sp<OMXCodec> codec = new OMXCodec(
                     omx, node, quirks, flags,
@@ -524,7 +524,7 @@
 }
 
 status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
-    ALOGV("configureCodec protected=%d",
+    ALOGE("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
 
     if (!(mFlags & kIgnoreCodecSpecificData)) {
@@ -755,6 +755,7 @@
         OMX_U32 portIndex,
         OMX_VIDEO_CODINGTYPE compressionFormat,
         OMX_COLOR_FORMATTYPE colorFormat) {
+    ALOGE("OMXCodec:PATCH:setVideoPortFormatType");
     OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = portIndex;
@@ -764,11 +765,13 @@
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
+        ALOGE("OMXCodec:PATCH:setVideoPortFormatType getParameter(OMX_IndexParamVideoPortFormat)");
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
 
         if (err != OK) {
+            ALOGE("OMXCodec:PATCH:setVideoPortFormatType getParameter(OMX_IndexParamVideoPortFormat) ERROR");
             return err;
         }
 
@@ -791,11 +794,13 @@
         if (index >= kMaxColorFormatSupported) {
             CODEC_LOGE("color format %d or compression format %d is not supported",
                 colorFormat, compressionFormat);
+            ALOGE("OMXCodec:PATCH:setVideoPortFormatType UNKNOWN_ERROR");
             return UNKNOWN_ERROR;
         }
     }
 
     if (!found) {
+        ALOGE("OMXCodec:PATCH:setVideoPortFormatType UNKNOWN_ERROR 2");
         return UNKNOWN_ERROR;
     }
 
@@ -838,11 +843,13 @@
 status_t OMXCodec::findTargetColorFormat(
         const sp<MetaData>& meta, OMX_COLOR_FORMATTYPE *colorFormat) {
     ALOGV("findTargetColorFormat");
+    ALOGE("OMXCodec:PATCH:findTargetColorFormat");
     CHECK(mIsEncoder);
 
     *colorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
     int32_t targetColorFormat;
     if (meta->findInt32(kKeyColorFormat, &targetColorFormat)) {
+        ALOGE("OMXCodec:PATCH:findTargetColorFormat %i", (OMX_COLOR_FORMATTYPE) targetColorFormat);
         *colorFormat = (OMX_COLOR_FORMATTYPE) targetColorFormat;
     }
 
@@ -852,6 +859,7 @@
 
 status_t OMXCodec::isColorFormatSupported(
         OMX_COLOR_FORMATTYPE colorFormat, int portIndex) {
+    ALOGE("OMXCodec:PATCH:isColorFormatSupported %i", colorFormat);
     ALOGV("isColorFormatSupported: %d", static_cast<int>(colorFormat));
 
     // Enumerate all the color formats supported by
@@ -863,6 +871,7 @@
     OMX_U32 index = 0;
     portFormat.nIndex = index;
     while (true) {
+        ALOGE("OMXCodec:PATCH:isColorFormatSupported %i getParameter(OMX_IndexParamVideoPortFormat)", colorFormat);
         if (OMX_ErrorNone != mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &portFormat, sizeof(portFormat))) {
@@ -871,7 +880,9 @@
         // Make sure that omx component does not overwrite
         // the incremented index (bug 2897413).
         CHECK_EQ(index, portFormat.nIndex);
+        ALOGE("OMXCodec:PATCH:isColorFormatSupported %i BUT IN CODEC %i)", colorFormat, portFormat.eColorFormat);
         if (portFormat.eColorFormat == colorFormat) {
+            ALOGE("OMXCodec:PATCH:isColorFormatSupported %i FOUND %i)", colorFormat, portFormat.eColorFormat);
             CODEC_LOGV("Found supported color format: %d", portFormat.eColorFormat);
             return OK;  // colorFormat is supported!
         }
@@ -891,6 +902,7 @@
 void OMXCodec::setVideoInputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
+    ALOGE("OMXCodec:PATCH:setVideoInputFormat");
     int32_t width, height, frameRate, bitRate, stride, sliceHeight;
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
@@ -1213,6 +1225,7 @@
 }
 
 status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
+    ALOGE("OMXCodec:PATCH:setupAVCEncoderParameters");
     int32_t iFramesInterval, frameRate, bitRate;
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
@@ -1289,12 +1302,13 @@
 status_t OMXCodec::setVideoOutputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
+    ALOGE("OMXCodec:PATCH:setVideoOutputFormat");
     int32_t width, height;
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
     CHECK(success);
 
-    CODEC_LOGV("setVideoOutputFormat width=%d, height=%d", width, height);
+    CODEC_LOGE("setVideoOutputFormat width=%d, height=%d", width, height);
 
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
@@ -1321,6 +1335,7 @@
             kPortIndexInput, compressionFormat, OMX_COLOR_FormatUnused);
 
     if (err != OK) {
+        ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] setVideoPortFormatType ERROR", mComponentName);
         return err;
     }
 
@@ -1338,6 +1353,12 @@
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
         int32_t colorFormat;
+
+        if (!strncmp("OMX.brcm.video.h264.hw.decoder", mComponentName, 30)) {
+            ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat BRCM set 19", mComponentName);
+            format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+        }
+        
         if (meta->findInt32(kKeyColorFormat, &colorFormat)
                 && colorFormat != OMX_COLOR_FormatUnused
                 && colorFormat != format.eColorFormat) {
@@ -1350,6 +1371,10 @@
                 if (format.eColorFormat == colorFormat) {
                     break;
                 }
+                if((unsigned int)err == 0x80001005){
+                    ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) colorFormat(%i) != format.eColorFormat (%i) OMX_ErrorNoMore", mComponentName, colorFormat, format.eColorFormat);
+                    err = OMX_ErrorNoMore;
+                }
             }
             if (format.eColorFormat != colorFormat) {
                 CODEC_LOGE("Color format %d is not supported", colorFormat);
@@ -1838,11 +1863,32 @@
 #endif
     }
 
+    ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat = %i", def.format.video.eColorFormat);
+
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    status_t errss;
+    
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, OMX_COLOR_FormatYUV420Planar);
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        case OMX_COLOR_FormatYUV420Planar:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        default:
+            ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+            HalColorFormat = def.format.video.eColorFormat;
+        break;
+    }
+
     err = setNativeWindowSizeFormatAndUsage(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat,
+            HalColorFormat,
             rotationDegrees,
             usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
     if (err != 0) {
@@ -4499,7 +4545,13 @@
                     caps->mColorFormats.push(flexibleEquivalent);
                 }
             }
-            caps->mColorFormats.push(portFormat.eColorFormat);
+            if(portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+                ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) portFormat.eColorFormat %i SET %i", portFormat.eColorFormat, OMX_COLOR_FormatYUV420Planar);
+                caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+            }else{
+                ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) DEFAULT portFormat.eColorFormat %i", portFormat.eColorFormat);
+                caps->mColorFormats.push(portFormat.eColorFormat);
+            }
         }
     }

diff --git a/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp b/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
index 8c949cb..133a234 100644
--- a/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -885,10 +885,17 @@ status_t OMXNodeInstance::createGraphicBufferSource(
     }

     if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {
+#ifdef HAWAII_HWC
+ // VC Encoder change OMX_COLOR_FormatAndroidOpaque to 0x7F000005
+ if (def.format.video.eColorFormat != 0x7F000005) {
+#endif
         CLOGW("createInputSurface requires COLOR_FormatSurface "
                 "(AndroidOpaque) color format instead of %s(%#x)",
                 asString(def.format.video.eColorFormat), def.format.video.eColorFormat);
         return INVALID_OPERATION;
+#ifdef HAWAII_HWC
+ }
+#endif

     }

     uint32_t usageBits;
diff -ur a/frameworks/base/telephony/java/android/telephony/TelephonyManager.java b/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
--- a/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2016-02-15 14:14:41.484779000 +0000
+++ b/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2016-02-15 14:44:40.636779000 +0000
@@ -3301,49 +3301,19 @@
      * @hide
      */
     public static void setTelephonyProperty(int phoneId, String property, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
-
         if (!SubscriptionManager.isValidPhoneId(phoneId)) {
             Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " prop=" + prop);
+                    " property=" + property + " value: " + value);
             return;
         }
 
-        for (int i = 0; i < phoneId; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
-        }
-
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = phoneId + 1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-
-        if (property.length() > SystemProperties.PROP_NAME_MAX
-                || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
-            Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " propVal=" + propVal);
-            return;
+        if (phoneId > 0) {
+            property += "_" + phoneId;
         }
 
         Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId +
-                " property=" + property + " value: " + value + " propVal=" + propVal);
-        SystemProperties.set(property, propVal);
+                " property=" + property + " value: " + value);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -3440,15 +3410,22 @@
      * @hide
      */
     public static String getTelephonyProperty(int phoneId, String property, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
-                propVal = values[phoneId];
-            }
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            Rlog.d(TAG, "getTelephonyProperty: invalid phoneId=" + phoneId +
+                    " property=" + property);
+            return defaultVal;
         }
-        return propVal == null ? defaultVal : propVal;
+
+        if (phoneId > 0) {
+            property += "_" + phoneId;
+        }
+
+        String propVal = SystemProperties.get(property);
+
+        Rlog.d(TAG, "getTelephonyProperty: return propVal='" + propVal + "' phoneId=" + phoneId
+                + " property='" + property + "' defaultVal='" + defaultVal);
+
+        return propVal.isEmpty() ? defaultVal : propVal;
     }
 
     /** @hide */
diff -ur a/frameworks/native/include/gui/ISurfaceComposer.h b/frameworks/native/include/gui/ISurfaceComposer.h
--- a/frameworks/native/include/gui/ISurfaceComposer.h	2016-02-15 14:14:33.144779000 +0000
+++ b/frameworks/native/include/gui/ISurfaceComposer.h	2016-02-15 14:44:40.640779000 +0000
@@ -150,6 +150,18 @@
             Rotation rotation = eRotateNone,
             bool isCpuConsumer = false) = 0;
 
+#ifdef USE_MHEAP_SCREENSHOT
+    /* Capture the specified screen. requires READ_FRAME_BUFFER permission
+     * This function will fail if there is a secure window on screen.
+     */
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform,
+            Rotation rotation = eRotateNone) = 0;
+#endif
+
     /* Clears the frame statistics for animations.
      *
      * Requires the ACCESS_SURFACE_FLINGER permission.
@@ -179,6 +191,9 @@
         GET_BUILT_IN_DISPLAY,
         SET_TRANSACTION_STATE,
         AUTHENTICATE_SURFACE,
+#ifdef USE_MHEAP_SCREENSHOT
+        CAPTURE_SCREEN_DEPRECATED,
+#endif
         GET_DISPLAY_CONFIGS,
         GET_ACTIVE_CONFIG,
         SET_ACTIVE_CONFIG,
diff -ur a/frameworks/native/include/gui/SurfaceComposerClient.h b/frameworks/native/include/gui/SurfaceComposerClient.h
--- a/frameworks/native/include/gui/SurfaceComposerClient.h	2016-02-15 14:14:33.144779000 +0000
+++ b/frameworks/native/include/gui/SurfaceComposerClient.h	2016-02-15 14:44:40.640779000 +0000
@@ -40,6 +40,9 @@
 
 class DisplayInfo;
 class Composer;
+#ifdef USE_MHEAP_SCREENSHOT
+class IMemoryHeap;
+#endif
 class ISurfaceComposerClient;
 class IGraphicBufferProducer;
 class Region;
@@ -193,6 +196,9 @@
             bool useIdentityTransform);
 
 private:
+#ifdef USE_MHEAP_SCREENSHOT
+    sp<IMemoryHeap> mHeap;
+#endif
     mutable sp<CpuConsumer> mCpuConsumer;
     mutable sp<IGraphicBufferProducer> mProducer;
     CpuConsumer::LockedBuffer mBuffer;
diff -ur a/frameworks/native/libs/binder/Parcel.cpp b/frameworks/native/libs/binder/Parcel.cpp
--- a/frameworks/native/libs/binder/Parcel.cpp	2016-02-15 14:14:33.132779000 +0000
+++ b/frameworks/native/libs/binder/Parcel.cpp	2016-02-15 14:44:40.640779000 +0000
@@ -859,6 +859,12 @@
     return writeString16(str.string(), str.size());
 }
 
+extern "C" status_t _ZN7android6Parcel13writeString16EPKDsj(void *parcel, const char16_t* str, size_t len);
+
+extern "C" status_t _ZN7android6Parcel13writeString16EPKtj(void *parcel, const char16_t* str, size_t len) {
+    return _ZN7android6Parcel13writeString16EPKDsj(parcel, str, len);
+}
+
 status_t Parcel::writeString16(const char16_t* str, size_t len)
 {
     if (str == NULL) return writeInt32(-1);
diff -ur a/frameworks/native/libs/gui/Android.mk b/frameworks/native/libs/gui/Android.mk
--- a/frameworks/native/libs/gui/Android.mk	2016-02-15 14:14:33.132779000 +0000
+++ b/frameworks/native/libs/gui/Android.mk	2016-02-15 14:44:40.640779000 +0000
@@ -82,6 +82,10 @@
 	liblog
 
 
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
 LOCAL_MODULE := libgui
 
 ifeq ($(TARGET_BOARD_PLATFORM), tegra)
diff -ur a/frameworks/native/libs/gui/BufferQueueProducer.cpp b/frameworks/native/libs/gui/BufferQueueProducer.cpp
--- a/frameworks/native/libs/gui/BufferQueueProducer.cpp	2016-02-15 14:14:33.128779000 +0000
+++ b/frameworks/native/libs/gui/BufferQueueProducer.cpp	2016-02-15 14:44:40.640779000 +0000
@@ -193,7 +193,12 @@
             const int newUndequeuedCount =
                 maxBufferCount - (dequeuedCount + 1);
             const int minUndequeuedCount =
+#ifdef HAWAII_HWC
+                // HACK: for some reason, we need to reduce min undequeue for screen recording
+                mCore->getMinUndequeuedBufferCountLocked(false);
+#else
                 mCore->getMinUndequeuedBufferCountLocked(async);
+#endif
             if (newUndequeuedCount < minUndequeuedCount) {
                 BQ_LOGE("%s: min undequeued buffer count (%d) exceeded "
                         "(dequeued=%d undequeued=%d)",
diff -ur a/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp b/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp
--- a/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp	2016-02-15 14:14:33.128779000 +0000
+++ b/frameworks/av/media/libstagefright/omx/GraphicBufferSource.cpp	2016-02-15 14:44:40.644779000 +0000
@@ -369,6 +369,7 @@ void GraphicBufferSource::codecBufferEmptied(OMX_BUFFERHEADERTYPE* header, int f
             }
         } else if (type == kMetadataBufferTypeANWBuffer
                 && header->nAllocLen >= sizeof(VideoNativeMetadata)) {
+#ifndef HAWAII_HWC
             VideoNativeMetadata &nativeMeta = *(VideoNativeMetadata *)data;
             if (nativeMeta.pBuffer != codecBuffer.mGraphicBuffer->getNativeBuffer()) {
                 // should never happen
@@ -376,6 +377,7 @@ void GraphicBufferSource::codecBufferEmptied(OMX_BUFFERHEADERTYPE* header, int f
                         nativeMeta.pBuffer, codecBuffer.mGraphicBuffer->getNativeBuffer());
                 CHECK(!"codecBufferEmptied: mismatched buffer");
             }
+#endif
         }
     }
 
diff -ur a/frameworks/native/libs/gui/ISurfaceComposer.cpp b/frameworks/native/libs/gui/ISurfaceComposer.cpp
--- a/frameworks/native/libs/gui/ISurfaceComposer.cpp	2016-02-15 14:14:33.128779000 +0000
+++ b/frameworks/native/libs/gui/ISurfaceComposer.cpp	2016-02-15 14:44:40.644779000 +0000
@@ -98,6 +98,33 @@
         remote()->transact(BnSurfaceComposer::BOOT_FINISHED, data, &reply);
     }
 
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(
+            const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform,
+            ISurfaceComposer::Rotation rotation)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
+        data.writeStrongBinder(display);
+        data.write(sourceCrop);
+        data.writeUint32(reqWidth);
+        data.writeUint32(reqHeight);
+        data.writeUint32(minLayerZ);
+        data.writeUint32(maxLayerZ);
+        data.writeInt32(static_cast<int32_t>(useIdentityTransform));
+        data.writeInt32(static_cast<int32_t>(rotation));
+        remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN_DEPRECATED, data, &reply);
+        *heap = interface_cast<IMemoryHeap>(reply.readStrongBinder());
+        *width = reply.readUint32();
+        *height = reply.readUint32();
+        return reply.readInt32();
+    }
+#endif
+
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
@@ -350,6 +377,31 @@
             bootFinished();
             return NO_ERROR;
         }
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED: {
+            CHECK_INTERFACE(ISurfaceComposer, data, reply);
+            sp<IBinder> display = data.readStrongBinder();
+            Rect sourceCrop;
+            data.read(sourceCrop);
+            uint32_t reqWidth = data.readUint32();
+            uint32_t reqHeight = data.readUint32();
+            uint32_t minLayerZ = data.readUint32();
+            uint32_t maxLayerZ = data.readUint32();
+            bool useIdentityTransform = static_cast<bool>(data.readInt32());
+            uint32_t rotation = data.readUint32();
+            sp<IMemoryHeap> heap;
+            uint32_t w, h;
+            status_t res = captureScreen(display, &heap, &w, &h,
+                    sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    useIdentityTransform,
+                    static_cast<ISurfaceComposer::Rotation>(rotation));
+            reply->writeStrongBinder(IInterface::asBinder(heap));
+            reply->writeUint32(w);
+            reply->writeUint32(h);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }
+#endif
         case CAPTURE_SCREEN: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
diff -ur a/frameworks/native/libs/gui/SurfaceComposerClient.cpp b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
--- a/frameworks/native/libs/gui/SurfaceComposerClient.cpp	2016-02-15 14:14:33.128779000 +0000
+++ b/frameworks/native/libs/gui/SurfaceComposerClient.cpp	2016-02-15 14:44:40.644779000 +0000
@@ -764,6 +764,14 @@
         uint32_t minLayerZ, uint32_t maxLayerZ, bool useIdentityTransform) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#if defined(SE_MHEAP_SCREENSHOT) && !defined(HAWAII_HWC)
+    int format = 0;
+    producer->query(NATIVE_WINDOW_FORMAT,&format);
+    if (format == PIXEL_FORMAT_RGBA_8888) {
+        /* For some reason, this format fails badly */
+        return BAD_VALUE;
+    }
+#endif
     return s->captureScreen(display, producer, sourceCrop,
             reqWidth, reqHeight, minLayerZ, maxLayerZ, useIdentityTransform,
             ISurfaceComposer::eRotateNone, SS_CPU_CONSUMER);
@@ -794,6 +802,19 @@
         bool useIdentityTransform, uint32_t rotation) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int ret = -1;
+    mHeap = 0;
+    ret = s->captureScreen(display, &mHeap, &mBuffer.width, &mBuffer.height, sourceCrop,
+            reqWidth, reqHeight, minLayerZ, maxLayerZ, useIdentityTransform,
+            static_cast<ISurfaceComposer::Rotation>(rotation));
+    if (ret == NO_ERROR) {
+        mBuffer.format = PIXEL_FORMAT_RGBA_8888;
+        mBuffer.stride = mBuffer.width;
+        mBuffer.data = static_cast<uint8_t*>(mHeap->getBase());
+    }
+    return ret;
+#else
     sp<CpuConsumer> cpuConsumer = getCpuConsumer();
 
     if (mHaveBuffer) {
@@ -813,6 +834,7 @@
         }
     }
     return err;
+#endif
 }
 
 status_t ScreenshotClient::update(const sp<IBinder>& display,
@@ -837,12 +859,16 @@
 }
 
 void ScreenshotClient::release() {
+#ifdef USE_MHEAP_SCREENSHOT
+    mHeap = 0;
+#else
     if (mHaveBuffer) {
         mCpuConsumer->unlockBuffer(mBuffer);
         memset(&mBuffer, 0, sizeof(mBuffer));
         mHaveBuffer = false;
     }
     mCpuConsumer.clear();
+#endif
 }
 
 void const* ScreenshotClient::getPixels() const {
diff -ur a/frameworks/native/services/surfaceflinger/Android.mk b/frameworks/native/services/surfaceflinger/Android.mk
--- a/frameworks/native/services/surfaceflinger/Android.mk	2016-02-15 14:14:33.144779000 +0000
+++ b/frameworks/native/services/surfaceflinger/Android.mk	2016-02-15 14:44:40.644779000 +0000
@@ -64,6 +64,10 @@
     LOCAL_CFLAGS += -DRUNNING_WITHOUT_SYNC_FRAMEWORK
 endif
 
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
 # See build/target/board/generic/BoardConfig.mk for a description of this setting.
 ifneq ($(VSYNC_EVENT_PHASE_OFFSET_NS),)
     LOCAL_CFLAGS += -DVSYNC_EVENT_PHASE_OFFSET_NS=$(VSYNC_EVENT_PHASE_OFFSET_NS)
diff -ur a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-15 14:14:33.144779000 +0000
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-15 14:44:40.644779000 +0000
@@ -26,6 +26,9 @@
 #include <stdatomic.h>
 
 #include <EGL/egl.h>
+#ifdef USE_MHEAP_SCREENSHOT
+#include <GLES/gl.h>
+#endif
 
 #include <cutils/log.h>
 #include <cutils/iosched_policy.h>
@@ -3008,12 +3011,18 @@
             break;
         }
         case CAPTURE_SCREEN:
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED:
+#endif
         {
             // codes that require permission check
             IPCThreadState* ipc = IPCThreadState::self();
             const int pid = ipc->getCallingPid();
             const int uid = ipc->getCallingUid();
             if ((uid != AID_GRAPHICS) &&
+#ifdef USE_MHEAP_SCREENSHOT
+                 (uid != AID_SYSTEM) &&
+#endif
                     !PermissionCache::checkPermission(sReadFramebuffer, pid, uid)) {
                 ALOGE("Permission Denial: "
                         "can't read framebuffer pid=%d, uid=%d", pid, uid);
@@ -3349,9 +3358,18 @@
             Mutex::Autolock _l(flinger->mStateLock);
             sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
             bool useReadPixels = this->useReadPixels && !flinger->mGpuToCpuSupported;
-            result = flinger->captureScreenImplLocked(hw, producer,
-                    sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
-                    useIdentityTransform, rotation, useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            if (!useReadPixels) {
+#endif
+                result = flinger->captureScreenImplLocked(hw, producer,
+                        sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                        useIdentityTransform, rotation, useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            } else {
+                // Should never get here
+                return BAD_VALUE;
+            }
+#endif
             static_cast<GraphicProducerWrapper*>(IInterface::asBinder(producer).get())->exit(result);
             return true;
         }
@@ -3469,6 +3487,11 @@
 {
     ATRACE_CALL();
 
+// Rotation artifact problems when useReadPixels is false
+#ifdef HAWAII_HWC
+    useReadPixels = true;
+#endif
+
     // get screen geometry
     uint32_t hw_w = hw->getWidth();
     uint32_t hw_h = hw->getHeight();
@@ -3671,6 +3694,139 @@
     drawWormhole(hw, region);
 }
 
+#ifdef USE_MHEAP_SCREENSHOT
+status_t SurfaceFlinger::captureScreenImplCpuConsumerLocked(
+        const sp<const DisplayDevice>& hw,
+        sp<IMemoryHeap>* heap, uint32_t* w, uint32_t* h,
+        Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useIdentityTransform, Transform::orientation_flags rotation)
+{
+    ATRACE_CALL();
+
+    // get screen geometry
+    const uint32_t hw_w = hw->getWidth();
+    const uint32_t hw_h = hw->getHeight();
+
+    if ((reqWidth > hw_w) || (reqHeight > hw_h)) {
+        ALOGE("size mismatch (%d, %d) > (%d, %d)",
+                reqWidth, reqHeight, hw_w, hw_h);
+        return BAD_VALUE;
+    }
+
+    reqWidth  = (!reqWidth)  ? hw_w : reqWidth;
+    reqHeight = (!reqHeight) ? hw_h : reqHeight;
+
+    status_t result = NO_ERROR;
+
+    renderScreenImplLocked(
+        hw, sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ, true,
+        useIdentityTransform, rotation);
+
+    size_t size = reqWidth * reqHeight * 4;
+    // allocate shared memory large enough to hold the
+    // screen capture
+    sp<MemoryHeapBase> base(
+            new MemoryHeapBase(size, 0, "screen-capture") );
+    void *vaddr = base->getBase();
+    glReadPixels(0, 0, reqWidth, reqHeight,
+            GL_RGBA, GL_UNSIGNED_BYTE, vaddr);
+    if (glGetError() == GL_NO_ERROR) {
+        *heap = base;
+        *w = reqWidth;
+        *h = reqHeight;
+        result = NO_ERROR;
+    } else {
+        result = INVALID_OPERATION;
+    }
+
+    return result;
+}
+
+status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
+        sp<IMemoryHeap>* heap, uint32_t* outWidth, uint32_t* outHeight,
+        Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useIdentityTransform, ISurfaceComposer::Rotation rotation)
+{
+    if (CC_UNLIKELY(display == 0))
+        return BAD_VALUE;
+
+    // Convert to surfaceflinger's internal rotation type.
+    Transform::orientation_flags rotationFlags;
+    switch (rotation) {
+        case ISurfaceComposer::eRotateNone:
+            rotationFlags = Transform::ROT_0;
+            break;
+        case ISurfaceComposer::eRotate90:
+            rotationFlags = Transform::ROT_90;
+            break;
+        case ISurfaceComposer::eRotate180:
+            rotationFlags = Transform::ROT_180;
+            break;
+        case ISurfaceComposer::eRotate270:
+            rotationFlags = Transform::ROT_270;
+            break;
+        default:
+            rotationFlags = Transform::ROT_0;
+            ALOGE("Invalid rotation passed to captureScreen(): %d\n", rotation);
+            break;
+    }
+
+    class MessageCaptureScreen : public MessageBase {
+        SurfaceFlinger* flinger;
+        sp<IBinder> display;
+        sp<IMemoryHeap>* heap;
+        uint32_t* outWidth;
+        uint32_t* outHeight;
+        Rect sourceCrop;
+        uint32_t reqWidth, reqHeight;
+        uint32_t minLayerZ,maxLayerZ;
+        bool useIdentityTransform;
+        Transform::orientation_flags rotation;
+        status_t result;
+    public:
+        MessageCaptureScreen(SurfaceFlinger* flinger,
+                const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+                uint32_t* outWidth, uint32_t* outHeight,
+                Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+                uint32_t minLayerZ, uint32_t maxLayerZ,
+                bool useIdentityTransform, Transform::orientation_flags rotation)
+            : flinger(flinger), display(display), heap(heap),
+              outWidth(outWidth), outHeight(outHeight),
+              sourceCrop(sourceCrop), reqWidth(reqWidth), reqHeight(reqHeight),
+              minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              useIdentityTransform(useIdentityTransform),
+              rotation(rotation),
+              result(PERMISSION_DENIED)
+        {
+        }
+        status_t getResult() const {
+            return result;
+        }
+        virtual bool handler() {
+            Mutex::Autolock _l(flinger->mStateLock);
+            sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
+            result = flinger->captureScreenImplCpuConsumerLocked(hw, heap,
+                    outWidth, outHeight,
+                    sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    useIdentityTransform, rotation);
+            return true;
+        }
+    };
+
+    sp<MessageBase> msg = new MessageCaptureScreen(this, display, heap,
+            outWidth, outHeight,
+            sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            useIdentityTransform, rotationFlags);
+    status_t res = postMessageSync(msg);
+    if (res == NO_ERROR) {
+        res = static_cast<MessageCaptureScreen*>( msg.get() )->getResult();
+    }
+    return res;
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 SurfaceFlinger::LayerVector::LayerVector() {
@@ -3717,6 +3873,7 @@
 }; // namespace android
 
 
+#ifndef USE_MHEAP_SCREENSHOT
 #if defined(__gl_h_)
 #error "don't include gl/gl.h in this file"
 #endif
@@ -3724,3 +3881,4 @@
 #if defined(__gl2_h_)
 #error "don't include gl2/gl2.h in this file"
 #endif
+#endif
diff -ur a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h	2016-02-15 14:14:33.144779000 +0000
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h	2016-02-15 14:44:40.652779000 +0000
@@ -218,6 +218,13 @@
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool useIdentityTransform, ISurfaceComposer::Rotation rotation,
             bool isCpuConsumer);
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform, ISurfaceComposer::Rotation rotation);
+#endif
     virtual status_t getDisplayStats(const sp<IBinder>& display,
             DisplayStatInfo* stats);
     virtual status_t getDisplayConfigs(const sp<IBinder>& display,
@@ -383,6 +390,15 @@
             bool useIdentityTransform, Transform::orientation_flags rotation,
             bool useReadPixels);
 
+#ifdef USE_MHEAP_SCREENSHOT
+    status_t captureScreenImplCpuConsumerLocked(
+            const sp<const DisplayDevice>& hw,
+            sp<IMemoryHeap>* heap, uint32_t* width, uint32_t* height,
+            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useIdentityTransform, Transform::orientation_flags rotation);
+#endif
+
     /* ------------------------------------------------------------------------
      * EGL
      */
diff -ur a/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-15 14:14:44.164779000 +0000
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-15 14:44:42.504779000 +0000
@@ -232,6 +232,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+    boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -463,6 +464,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+        // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -2172,6 +2178,18 @@
     public void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+
+        // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -2767,6 +2785,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+        pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2016-02-15 14:14:44.156779000 +0000
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2016-02-15 14:44:42.504779000 +0000
@@ -303,7 +303,7 @@
     static final int RESPONSE_SOLICITED = 0;
     static final int RESPONSE_UNSOLICITED = 1;
 
-    static final String[] SOCKET_NAME_RIL = {"rild", "rild2", "rild3"};
+    static final String[] SOCKET_NAME_RIL = {"rild", "rild1", "rild2"};
 
     static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
 
diff -ur a/hardware/broadcom/libbt/src/userial_vendor.c b/hardware/broadcom/libbt/src/userial_vendor.c
--- a/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-15 14:14:00.740779000 +0000
+++ b/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-15 14:44:42.504779000 +0000
@@ -197,6 +197,10 @@
     uint16_t parity;
     uint8_t stop_bits;
 
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    int ldisc;
+#endif
+
     vnd_userial.fd = -1;
 
     if (!userial_to_tcio_baud(p_cfg->baud, &baud))
@@ -266,6 +270,13 @@
     tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
 
 #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    // TODO: check for breakage on tuna (Galaxy Nexus). It defines this,
+    //       but does not contain the kernel code to support it.
+
+    // Switch to N_BRCM_HCI line disclipline for ioctl to work
+    ldisc = 25; // N_BRCM_HCI
+    ioctl(vnd_userial.fd, TIOCSETD, &ldisc);
+
     userial_ioctl_init_bt_wake(vnd_userial.fd);
 #endif
 
diff --git a/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java b/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java 
index 83ed5eb..0fcf7ee 100644 
--- a/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java 
+++ b/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java
@@ -22,5 +22,5 @@ private JniLibName() {
             }

            public static final String JNI_LIB_NAME = "jni_latinime";
-           public static final String JNI_LIB_NAME2 = "jni_latinimegoogle";
+          public static final String JNI_LIB_NAME2 = "jni_unbundled_latinimegoogle";
 }

diff -ur a/packages/services/Telephony/res/values/strings.xml b/packages/services/Telephony/res/values/strings.xml
--- a/packages/services/Telephony/res/values/strings.xml	2016-02-15 14:14:45.276779000 +0000
+++ b/packages/services/Telephony/res/values/strings.xml	2016-02-15 14:51:32.868779000 +0000
@@ -632,12 +632,14 @@
     </string-array>
 
     <string-array name="enabled_networks_except_lte_choices" translatable="false">
-        <item>@string/network_3G</item>
-        <item>@string/network_2G</item>
+        <item>@string/preferred_network_mode_wcdma_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_wcdma_preferred_choice</item>
     </string-array>
     <string-array name="enabled_networks_except_lte_values" translatable="false">
-        <item>"0"</item>
+        <item>"2"</item>
         <item>"1"</item>
+        <item>"0"</item>
     </string-array>
 
     <string-array name="enabled_networks_except_gsm_lte_choices" translatable="false">
diff -ur a/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java b/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java
--- a/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	2016-02-15 14:14:45.392779000 +0000
+++ b/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	2016-02-15 14:51:32.868779000 +0000
@@ -1200,7 +1200,7 @@
             case Phone.NT_MODE_WCDMA_ONLY:
                 mButtonEnabledNetworks.setValue(
                         Integer.toString(Phone.NT_MODE_WCDMA_ONLY));
-                mButtonEnabledNetworks.setSummary(R.string.network_wcdma_only);
+                mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_wcdma_only_choice);
                 break;
             case Phone.NT_MODE_GSM_UMTS:
                 mButtonEnabledNetworks.setValue(
@@ -1210,12 +1210,12 @@
             case Phone.NT_MODE_WCDMA_PREF:
                 mButtonEnabledNetworks.setValue(
                         Integer.toString(Phone.NT_MODE_WCDMA_PREF));
-                mButtonEnabledNetworks.setSummary(R.string.network_wcdma_pref);
+                mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_gsm_wcdma_preferred_choice);
                 break;
             case Phone.NT_MODE_GSM_ONLY:
                 mButtonEnabledNetworks.setValue(
                         Integer.toString(Phone.NT_MODE_GSM_ONLY));
-                mButtonEnabledNetworks.setSummary(R.string.network_gsm_only);
+                mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_gsm_only_choice);
                 break;
             case Phone.NT_MODE_LTE_GSM_WCDMA:
                 if (isWorldMode()) {
diff -ur a/system/core/include/utils/VectorImpl.h b/system/core/include/utils/VectorImpl.h
--- a/system/core/include/utils/VectorImpl.h	2016-02-15 14:15:25.848779000 +0000
+++ b/system/core/include/utils/VectorImpl.h	2016-02-15 14:44:42.504779000 +0000
@@ -105,7 +105,19 @@
     virtual void            do_splat(void* dest, const void* item, size_t num) const = 0;
     virtual void            do_move_forward(void* dest, const void* from, size_t num) const = 0;
     virtual void            do_move_backward(void* dest, const void* from, size_t num) const = 0;
-    
+
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedVectorImpl1();
+    virtual void            reservedVectorImpl2();
+    virtual void            reservedVectorImpl3();
+    virtual void            reservedVectorImpl4();
+    virtual void            reservedVectorImpl5();
+    virtual void            reservedVectorImpl6();
+    virtual void            reservedVectorImpl7();
+    virtual void            reservedVectorImpl8();
+#endif
+
 private:
         void* _grow(size_t where, size_t amount);
         void  _shrink(size_t where, size_t amount);
@@ -156,6 +168,18 @@
 protected:
     virtual int             do_compare(const void* lhs, const void* rhs) const = 0;
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedSortedVectorImpl1();
+    virtual void            reservedSortedVectorImpl2();
+    virtual void            reservedSortedVectorImpl3();
+    virtual void            reservedSortedVectorImpl4();
+    virtual void            reservedSortedVectorImpl5();
+    virtual void            reservedSortedVectorImpl6();
+    virtual void            reservedSortedVectorImpl7();
+    virtual void            reservedSortedVectorImpl8();
+#endif
+
 private:
             ssize_t         _indexOrderOf(const void* item, size_t* order = 0) const;
 
diff -ur a/system/core/init/init.cpp b/system/core/init/init.cpp
--- a/system/core/init/init.cpp	2016-02-15 14:15:25.860779000 +0000
+++ b/system/core/init/init.cpp	2016-02-15 14:44:42.508779000 +0000
@@ -75,6 +75,8 @@
 #define BOARD_CHARGING_CMDLINE_VALUE "true"
 #endif
 
+static char hardware[32];
+static unsigned revision = 0;
 static char qemu[32];
 static char battchg_pause[32];
 
@@ -806,6 +808,9 @@
 }
 
 static void export_kernel_boot_props() {
+    char tmp[PROP_VALUE_MAX];
+    int ret;
+
     struct {
         const char *src_prop;
         const char *dst_prop;
@@ -817,16 +822,25 @@
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
-#ifndef IGNORE_RO_BOOT_REVISION
-        { "ro.boot.revision",   "ro.revision",   "0", },
-#endif
     };
     for (size_t i = 0; i < ARRAY_SIZE(prop_map); i++) {
         char value[PROP_VALUE_MAX];
         int rc = property_get(prop_map[i].src_prop, value);
         property_set(prop_map[i].dst_prop, (rc > 0) ? value : prop_map[i].default_value);
     }
+   get_hardware_name(hardware, &revision);
+
+   /* if this was given on kernel command line, override what we read
+    * before (e.g. from /proc/cpuinfo), if anything */
+   ret = property_get("ro.boot.hardware", tmp);
+   if (ret)
+       strlcpy(hardware, tmp, sizeof(hardware));
+   property_set("ro.hardware", hardware);
+
+   ret = property_get("ro.boot.revision", tmp);
+   if (!ret)
+       snprintf(tmp, PROP_VALUE_MAX, "%d", revision);
+   property_set("ro.revision", tmp);
 }
 
 static void process_kernel_dt(void)
diff -ur a/system/core/init/util.cpp b/system/core/init/util.cpp
--- a/system/core/init/util.cpp	2016-02-15 14:15:25.860779000 +0000
+++ b/system/core/init/util.cpp	2016-02-15 14:44:42.508779000 +0000
@@ -401,6 +401,34 @@
     }
 }
 
+void get_hardware_name(char *hardware, unsigned int *revision) {
+  FILE* fp = fopen("/proc/cpuinfo", "re");
+  if (fp == NULL) {
+    return;
+  }
+  char buf[1024];
+  while (fgets(buf, sizeof(buf), fp) != NULL) {
+    if (strncmp(buf, "Hardware", 8) == 0) {
+      const char* hw = strstr(buf, ": ");
+      if (hw) {
+        hw += 2;
+        size_t n = 0;
+        while (*hw) {
+          if (!isspace(*hw)) {
+            hardware[n++] = tolower(*hw);
+          }
+          hw++;
+          if (n == 31) break;
+        }
+        hardware[n] = 0;
+      }
+    } else if (strncmp(buf, "Revision", 8) == 0) {
+      sscanf(buf, "Revision : %ux", revision);
+    }
+  }
+  fclose(fp);
+}
+
 void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)> import_kernel_nv)
 {
     char cmdline[2048];
diff -ur a/system/core/init/util.h b/system/core/init/util.h
--- a/system/core/init/util.h	2016-02-15 14:15:25.860779000 +0000
+++ b/system/core/init/util.h	2016-02-15 14:44:42.508779000 +0000
@@ -58,6 +58,7 @@
 void remove_link(const char *oldpath, const char *newpath);
 int wait_for_file(const char *filename, int timeout);
 void open_devnull_stdio(void);
+void get_hardware_name(char *hardware, unsigned int *revision);
 void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)>);
 int make_dir(const char *path, mode_t mode);
 int restorecon(const char *pathname);
diff -ur a/system/core/libnetutils/ifc_utils.c b/system/core/libnetutils/ifc_utils.c
--- a/system/core/libnetutils/ifc_utils.c	2016-02-15 14:15:25.852779000 +0000
+++ b/system/core/libnetutils/ifc_utils.c	2016-02-15 14:44:42.508779000 +0000
@@ -703,3 +703,19 @@
 
     return 0;
 }
+
+// Required for Broadcom RILD
+int ifc_set_mtu(const char *name, int mtuSz)
+{
+    struct ifreq ifr;
+    int ret;
+    ifc_init_ifr(name, &ifr);
+    ifr.ifr_mtu = mtuSz;
+
+    ret = ioctl(ifc_ctl_sock, SIOCSIFMTU, &ifr);
+    if (ret < 0) {
+        printerr("ifc_set_mtu: SIOCSIFMTU failed: %d\n", ret);
+    }
+
+    return ret;
+}
diff -ur a/system/core/libutils/RefBase.cpp b/system/core/libutils/RefBase.cpp
--- a/system/core/libutils/RefBase.cpp	2016-02-15 14:15:25.840779000 +0000
+++ b/system/core/libutils/RefBase.cpp	2016-02-15 14:44:42.508779000 +0000
@@ -630,6 +630,13 @@
 
 // ---------------------------------------------------------------------------
 
+#ifdef REFBASE_JB_MR1_COMPAT_SYMBOLS
+extern "C" void _ZN7android7RefBase14moveReferencesEPvPKvjRKNS_22ReferenceConverterBaseE(void* /*dst*/, void const* /*src*/, size_t /*n*/,
+        const ReferenceConverterBase& /*caster*/)
+{
+}
+#endif
+
 #if DEBUG_REFS
 void RefBase::renameRefs(size_t n, const ReferenceRenamer& renamer) {
     for (size_t i=0 ; i<n ; i++) {
diff -ur a/system/core/libutils/VectorImpl.cpp b/system/core/libutils/VectorImpl.cpp
--- a/system/core/libutils/VectorImpl.cpp	2016-02-15 14:15:25.840779000 +0000
+++ b/system/core/libutils/VectorImpl.cpp	2016-02-15 14:44:42.508779000 +0000
@@ -552,6 +552,17 @@
     do_move_backward(dest, from, num);
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void VectorImpl::reservedVectorImpl1() { }
+void VectorImpl::reservedVectorImpl2() { }
+void VectorImpl::reservedVectorImpl3() { }
+void VectorImpl::reservedVectorImpl4() { }
+void VectorImpl::reservedVectorImpl5() { }
+void VectorImpl::reservedVectorImpl6() { }
+void VectorImpl::reservedVectorImpl7() { }
+void VectorImpl::reservedVectorImpl8() { }
+#endif
+
 /*****************************************************************************/
 
 SortedVectorImpl::SortedVectorImpl(size_t itemSize, uint32_t flags)
@@ -667,6 +678,17 @@
     return i;
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void SortedVectorImpl::reservedSortedVectorImpl1() { };
+void SortedVectorImpl::reservedSortedVectorImpl2() { };
+void SortedVectorImpl::reservedSortedVectorImpl3() { };
+void SortedVectorImpl::reservedSortedVectorImpl4() { };
+void SortedVectorImpl::reservedSortedVectorImpl5() { };
+void SortedVectorImpl::reservedSortedVectorImpl6() { };
+void SortedVectorImpl::reservedSortedVectorImpl7() { };
+void SortedVectorImpl::reservedSortedVectorImpl8() { };
+#endif
+
 /*****************************************************************************/
 
 }; // namespace android
